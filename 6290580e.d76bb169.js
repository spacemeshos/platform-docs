(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{111:function(e,t,o){"use strict";o.d(t,"a",(function(){return l})),o.d(t,"b",(function(){return u}));var a=o(0),n=o.n(a);function i(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function s(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){i(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function c(e,t){if(null==e)return{};var o,a,n=function(e,t){if(null==e)return{};var o,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var h=n.a.createContext({}),p=function(e){var t=n.a.useContext(h),o=t;return e&&(o="function"==typeof e?e(t):s(s({},t),e)),o},l=function(e){var t=p(e.components);return n.a.createElement(h.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},m=n.a.forwardRef((function(e,t){var o=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,h=c(e,["components","mdxType","originalType","parentName"]),l=p(o),m=a,u=l["".concat(r,".").concat(m)]||l[m]||d[m]||i;return o?n.a.createElement(u,s(s({ref:t},h),{},{components:o})):n.a.createElement(u,s({ref:t},h))}));function u(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=o.length,r=new Array(i);r[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var h=2;h<i;h++)r[h]=o[h];return n.a.createElement.apply(null,r)}return n.a.createElement.apply(null,o)}m.displayName="MDXCreateElement"},171:function(e,t,o){"use strict";o.r(t),t.default=o.p+"assets/images/poet-dag-7d1cb9e30035d07275419afd62d31334.png"},86:function(e,t,o){"use strict";o.r(t),o.d(t,"frontMatter",(function(){return r})),o.d(t,"metadata",(function(){return s})),o.d(t,"toc",(function(){return c})),o.d(t,"default",(function(){return p}));var a=o(3),n=o(7),i=(o(0),o(111)),r={id:"poet",title:"Mining - Proof of Elapsed Time",sidebar_label:"PoET"},s={unversionedId:"protocol/mining/poet",id:"protocol/mining/poet",isDocsHomePage:!1,title:"Mining - Proof of Elapsed Time",description:'Proof of Elapsed Time, or PoET, is a cryptographic primitive used to prove that a specific amount of real (clock) time has elapsed. Elapsed time is measured by iterating a sequential work cycle that takes a set amount of time to execute. The algorithm provides a proof that it has worked sequentially for a predetermined number of cycles, and thus proves that the period of time determined by its parameters has elapsed during its entire execution. By committing to knowledge of some information (known as a "statement") as input to the proof-generation algorithm, a prover can assert cryptographically that they had knowledge of that information as of a given point in time.',source:"@site/docs/protocol/mining/03-poet.md",slug:"/protocol/mining/poet",permalink:"/docs/next/protocol/mining/poet",editUrl:"https://github.com/spacemeshos/platform-docs/blob/main/docs/protocol/mining/03-poet.md",version:"current",lastUpdatedBy:"Aviv Eyal",lastUpdatedAt:1615307334,sidebar_label:"PoET",sidebar:"someSidebar",previous:{title:"Mining - Proof of Space-time",permalink:"/docs/next/protocol/mining/post"},next:{title:"Mining - Activations",permalink:"/docs/next/protocol/mining/activations"}},c=[{value:"Construction",id:"construction",children:[{value:"Further details",id:"further-details",children:[]}]},{value:"PoET Service",id:"poet-service",children:[]},{value:"Chaining PoST and PoET",id:"chaining-post-and-poet",children:[]}],h={toc:c};function p(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},h,r,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,'Proof of Elapsed Time, or PoET, is a cryptographic primitive used to prove that a specific amount of real (clock) time has elapsed. Elapsed time is measured by iterating a sequential work cycle that takes a set amount of time to execute. The algorithm provides a proof that it has worked sequentially for a predetermined number of cycles, and thus proves that the period of time determined by its parameters has elapsed during its entire execution. By committing to knowledge of some information (known as a "statement") as input to the proof-generation algorithm, a prover can assert cryptographically that they had knowledge of that information as of a given point in time.'),Object(i.b)("p",null,"In the context of Spacemesh, PoET is used to introduce the concept of ",Object(i.b)("em",{parentName:"p"},"time")," to the eligibility proofs submitted by miners by measuring the time interval between two executions of the ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/mining/post"},"PoST algorithm"),". In effect, PoET allows a miner to assert not only that they previously generated a set of data (the initialization phase of PoST), but that they still have access to that data after some time has elapsed (the execution phase)\u2014hence, proofs of ",Object(i.b)("em",{parentName:"p"},"space-time.")),Object(i.b)("p",null,"A naive cryptographic approach to proving elapsed time is proof of work, i.e., using computational effort spent as a proxy for elapsed time. But while proof of work attests to a certain amount of computational work having been performed, it does not strictly correspond to elapsed clock time, since the work may be parallelized. Thus in order to prove elapsed time we must use a construction that requires ",Object(i.b)("em",{parentName:"p"},"inherently sequential work"),", i.e., where each unit of work depends upon the output of the previous unit, so that parallelization could not reduce the duration taken to complete the work (while still being bound to a single-core CPU speed, which can vary, but has a practical limit). This sort of construction is sometimes referred to as Proof of Sequential Work (PoSW), which can be used as a proxy for Proof of Elapsed Time (PoET)."),Object(i.b)("p",null,"The underlying idea is that it\u2019s extremely hard to make the computation of an iterated sequence of hashes faster then the fastest consumer-grade CPU, in particular if we use a hash function (such as SHA256) that mainstream CPU makers have already spent considerable resources accelerating. This is in sharp contrast to increasing ",Object(i.b)("em",{parentName:"p"},"total work throughput")," (i.e., the sort of work required by most computationally intensive applications), which can be done by parallelizing the work."),Object(i.b)("p",null,"PoSW was first introduced in a 2013 paper by Mohammad Mahmoody, Tal Moran and Salil P. Vadhan (",Object(i.b)("a",{parentName:"p",href:"https://eprint.iacr.org/2011/553"},"MMV13"),"). It is a protocol for proving that one performed ",Object(i.b)("em",{parentName:"p"},"sequential")," computational work related to some statement, such that a minimum amount of time has passed since that statement became known to the actor performing the work (with a proof that\u2019s publicly and efficiently verifiable). The initial motivation for such proofs was not blockchain designs but rather applications including document timestamping and universally verifiable CPU benchmarks. The construction of MMV13 is based on \u201cdepth-robust\u201d graphs, which are designed to be memory hard (i.e., requiring not only a large amount of time but also a large amount of space to create a proof), making it impractical to use in a production blockchain."),Object(i.b)("p",null,"A much simpler and more efficient construction was introduced in 2018 by Bram Cohen and Krzysztof Pietrzak (",Object(i.b)("a",{parentName:"p",href:"https://eprint.iacr.org/2018/183"},"CP18"),"), winning the best paper award in Eurocrypt that year. It replaces the MMV13 depth-robust graph with a graph based on a Merkle tree. The Spacemesh protocol uses an open source ",Object(i.b)("a",{parentName:"p",href:"https://github.com/spacemeshos/poet"},"implementation")," of the CP18 spec."),Object(i.b)("h2",{id:"construction"},"Construction"),Object(i.b)("p",null,"Unlike the PoST construction, PoET construction occurs in a single phase. At the very highest level of abstraction, it involves the first party, the prover, running an arbitrary, agreed-upon piece of information (known as the \u201cstatement\u201d) through an agreed-upon hash function for an agreed-upon period of time (",Object(i.b)("em",{parentName:"p"},"t,")," which in practice species the depth of the graph that's generated, where a larger graph results in more repetitions of the hash function, as a proxy for elapsed wall time). The prover then generates a proof based on the results and publishes it for anyone to independently verify. As with PoST, and as described further in ",Object(i.b)("a",{parentName:"p",href:"https://eprint.iacr.org/2018/183"},"CP18"),", PoET is made non-interactive, enabling independent verification of the proof, via the use of Fiat-Shamir. Read on to better understand the protocol."),Object(i.b)("a",{name:"algorithm"}),"### Non-interactive protocol",Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"All parties, including anyone who will independently verify generated proofs, agree on set of shared parameters, including the designated period of time, ",Object(i.b)("em",{parentName:"li"},"t")," (i.e., the depth of the graph), and the number of leaves to be included in a proof"),Object(i.b)("li",{parentName:"ol"},"Prover receives a statement, then using the statement as input runs the hash function for ",Object(i.b)("em",{parentName:"li"},"t")," time, i.e., generates a graph of a specified depth, calculates a commitment to that graph (Merkle root), derives the challenge from the commitment (using the ",Object(i.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic"},"Fiat-Shamir heuristic"),"), generates a proof (a set of labels and Merkle paths corresponding to the derived challenge). Publishes statement, Merkle root, and proof."),Object(i.b)("li",{parentName:"ol"},"Verifier independently derives the challenge from the Merkle root (using the Fiat-Shamir heuristic), verifies the proof. If accepted, verifier is convinced that ",Object(i.b)("em",{parentName:"li"},"t")," time has passed since statement was learned by the prover. (See the next section for more information on how this happens.)")),Object(i.b)("h3",{id:"further-details"},"Further details"),Object(i.b)("p",null,"The algorithm described above still leaves out some important details for the sake of readability and clarity, including the details of how verification works, as well as further details about how the graph is constructed in a ",Object(i.b)("em",{parentName:"p"},"sequential")," fashion."),Object(i.b)("h4",{id:"verification"},"Verification"),Object(i.b)("p",null,"The verifier first uses Fiat-Shamir to derive the deterministic challenge based on the Merkle root that the prover committed to (as in PoST), i.e., a random set of leaf indices. She then verifies that the proof contains the correct number of Merkle paths and that the set of Merkle paths matches the committed-to Merkle root. Finally, she independently runs the hash function to recompute the labels for the chosen leaves to make sure that they match the values contained in the proof."),Object(i.b)("h4",{id:"sequential-graph-construction"},"Sequential graph construction"),Object(i.b)("p",null,"In order to construct the graph (a directed acyclic graph, or DAG), the label of each leaf node is the hash of the concatenation of the list of its left siblings on the path to the root node (this is what makes the work ",Object(i.b)("em",{parentName:"p"},"sequential"),"), salted with the statement (this is how the prover proves knowledge of the statement before beginning the algorithm). The label of each intermediate node is the hash of the concatenation of its children (left and then right), salted with the statement. For more details on the algorithm, see the ",Object(i.b)("a",{parentName:"p",href:"https://eprint.iacr.org/2018/183"},"CP18")," paper and the open source ",Object(i.b)("a",{parentName:"p",href:"https://github.com/spacemeshos/poet"},"implementation"),"."),Object(i.b)("p",null,Object(i.b)("img",{alt:"Visualization of PoET graph construction",src:o(171).default,title:"Visualization of PoET graph construction"})),Object(i.b)("p",null,"Construction of the DAG"),Object(i.b)("h2",{id:"poet-service"},"PoET Service"),Object(i.b)("p",null,"Miners are not expected to perform the sequential work themselves, as this would contradict one of the main goals of the Spacemesh protocol, energy efficiency, since it would require continuous CPU work."),Object(i.b)("p",null,"The trick is that ",Object(i.b)("em",{parentName:"p"},"a single PoET instance can be shared among an arbitrary number of miners,")," so the amortized CPU cost drops as the number of miners utilizing a given PoET service grows. Since what\u2019s needed is merely a proof that a certain amount of time has elapsed, proving that ",Object(i.b)("em",{parentName:"p"},"someone")," did sequential work is sufficient: the work does not have to have been performed by the miner itself!"),Object(i.b)("p",null,"In Spacemesh, a single PoET service is sufficient to provide a proof on behalf of many miners. Each of these miners can independently, efficiently verify the correctness of the output of the service."),Object(i.b)("p",null,"A miner registers with a public PoET service by submitting their input (a hash of a challenge constructed using their previous ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/mining/activations"},"ATX"),", which contains their previous PoST) during the window advertised by the service. The service then creates a graph based on a Merkle tree whose leaves are the aggregate inputs from each miner, uses the root of the tree as the input (statement), runs the PoSW algorithm, and outputs a single, shared PoET proof that can be used by any of the registered miners."),Object(i.b)("p",null,"In addition to the non-interactive proof whose input is the Merkle root of this graph created on the aggregate input (the \u201cstatement,\u201d in the ",Object(i.b)("a",{parentName:"p",href:"#algorithm"},"algorithm laid out above"),"), the PoET service can also provide Merkle paths from specific leaves (i.e., specific miner inputs) to that Merkle root. This allows individual miners to verify to themselves, and prove to others, that their input was included."),Object(i.b)("p",null,"However, in Spacemesh, since many miners in practice share a single proof, it would be redundant for them each to publish an individual Merkle proof (i.e., it would be a waste of mesh storage space). There is another, more efficient way of establishing that every miner input is an element of the Merkle root (statement), and so validated by the shared proof: the PoET service itself broadcasts the ",Object(i.b)("em",{parentName:"p"},"ordered list of all miner inputs")," to the Spacemesh network via a Spacemesh-compatible gateway node (i.e., a node running a Spacemesh full node). Any verifier can then independently verify that each miner's proof is valid, i.e., that its input was included in a given PoET run."),Object(i.b)("h2",{id:"chaining-post-and-poet"},"Chaining PoST and PoET"),Object(i.b)("p",null,"The last section, ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/mining/post"},"Proof of Space-time"),", explained how a prover can assert in a deterministic, independently verifiable, non-interactive fashion that they generated and still have access to a particular dataset derived from a known seed, based on their unique ID. This section explains how a prover can assert, in the same fashion, that a specific amount of objective time (measured using repetitions of an agreed-upon algorithm as a proxy for time) has passed since they had knowledge of a statement. The next section, ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/mining/nipost"},"Non-interactive Proof of Space-time"),", ties these two ideas together and explains how PoST and PoET proofs can be chained to assert ",Object(i.b)("em",{parentName:"p"},"ongoing")," commitment to the dataset for an arbitrarily long period of time."))}p.isMDXComponent=!0}}]);