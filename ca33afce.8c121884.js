(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{101:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return r})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return d}));var n=a(3),i=a(7),o=(a(0),a(109)),r={id:"overview",title:"Transactions",sidebar_label:"Transactions"},s={unversionedId:"protocol/transactions/overview",id:"version-0.1.0/protocol/transactions/overview",isDocsHomePage:!1,title:"Transactions",description:'The transaction is one of the most basic data structures used in Spacemesh and in many other blockchain protocols. In Spacemesh, there are three types of transactions: a simple coin transfer, an activation transaction (ATX), and a smart contract call. Activation transactions are a special type of transaction used as part of the mining process. They are described in the mining docs. Smart contract transactions are part of the experimental Spacemesh Virtual Machine (SVM) project, which is not in production yet. Throughout the rest of this document, the term "transaction" refers to a coin transfer.',source:"@site/versioned_docs/version-0.1.0/protocol/transactions/01-overview.md",slug:"/protocol/transactions/overview",permalink:"/docs/protocol/transactions/overview",editUrl:"https://github.com/spacemeshos/platform-docs/blob/main/versioned_docs/version-0.1.0/protocol/transactions/01-overview.md",version:"0.1.0",lastUpdatedBy:"Aviv Eyal",lastUpdatedAt:1615316854,sidebar_label:"Transactions",sidebar:"version-0.1.0/someSidebar",previous:{title:"Sync",permalink:"/docs/protocol/sync/overview"},next:{title:"Spacemesh API Documentation",permalink:"/docs/api/overview"}},c=[{value:"Account model",id:"account-model",children:[{value:"Address format and signature scheme",id:"address-format-and-signature-scheme",children:[]}]},{value:"Transaction structure",id:"transaction-structure",children:[{value:"Syntactic validity",id:"syntactic-validity",children:[]}]},{value:"Mining transactions",id:"mining-transactions",children:[{value:"Mempool and gossip",id:"mempool-and-gossip",children:[]},{value:"Assembling blocks",id:"assembling-blocks",children:[]}]},{value:"Applying transactions",id:"applying-transactions",children:[{value:"Contextual validity",id:"contextual-validity",children:[]},{value:"Global state",id:"global-state",children:[]},{value:"Fees and rewards",id:"fees-and-rewards",children:[]}]}],l={toc:c};function d(e){var t=e.components,a=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The transaction is one of the most basic data structures used in Spacemesh and in many other blockchain protocols. In Spacemesh, there are three types of transactions: a simple coin transfer, an activation transaction (ATX), and a smart contract call. Activation transactions are a special type of transaction used as part of the mining process. They are ",Object(o.b)("a",{parentName:"p",href:"/docs/protocol/mining/activations"},"described in the mining docs"),". Smart contract transactions are part of the experimental ",Object(o.b)("a",{parentName:"p",href:"https://github.com/spacemeshos/svm"},"Spacemesh Virtual Machine (SVM)"),' project, which is not in production yet. Throughout the rest of this document, the term "transaction" refers to a coin transfer.'),Object(o.b)("p",null,"In Spacemesh, a transaction is an order to transfer funds from one account to another. The transaction specifies the amount to be transferred, the sender's wallet address, the recipient's wallet address, and the fee to be paid to the miner that mines the transaction. The transaction is signed using the private key of the sender, which is how the protocol knows that the transaction is legitimate (i.e., that it originated with the holder of the sender's private key)."),Object(o.b)("h2",{id:"account-model"},"Account model"),Object(o.b)("p",null,"Spacemesh uses the account model for storing value. This means that users are encouraged to reuse accounts for multiple transactions, similar to a bank account, rather than generate a new address for every transaction (as in the UTXO model). When multiple transactions increase the balance of an account, the funds from different transactions become fungible and indistinguishable from one another."),Object(o.b)("p",null,"An account in Spacemesh is a mapping from a wallet address to a balance of Smesh tokens. Note that there is not a one-to-one mapping between ",Object(o.b)("em",{parentName:"p"},"users")," and ",Object(o.b)("em",{parentName:"p"},"addresses,")," as one user may control many addresses (or, less often but also possibly, one address could be controlled by many users)."),Object(o.b)("p",null,"Even though a transaction is signed, so that the protocol can verify that it came from the sender, without additional protections, transactions are still susceptible to a ",Object(o.b)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Replay_attack"},"replay attack"),': if Alice sends funds to Bob, Bob could resend the same transaction (that Alice already signed) to the network to steal additional funds from Alice. In order to prevent replay attacks, each account also stores a transaction counter (some other platforms such as Ethereum call this a "nonce"). Each transaction must declare a counter, and a transaction is only valid if it has a counter that matches the current value of the account counter.'),Object(o.b)("h3",{id:"address-format-and-signature-scheme"},"Address format and signature scheme"),Object(o.b)("p",null,"Spacemesh uses the standard ",Object(o.b)("inlineCode",{parentName:"p"},"curve25519")," to generate keypairs. A private key is a random 32 byte number, and the public key is generated from the private key. The Spacemesh address is the 20-byte suffix of the public key. In other words, the wallet address may be expressed as:"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"address = Bytes[12..31](public_key)")),Object(o.b)("h2",{id:"transaction-structure"},"Transaction structure"),Object(o.b)("p",null,"The actual transaction data structure in Spacemesh contains the following:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Recipient's address (20 bytes)"),Object(o.b)("li",{parentName:"ul"},"Amount to transfer (8 bytes)"),Object(o.b)("li",{parentName:"ul"},"Amount of the fee to be paid (to the miner) (8 bytes)"),Object(o.b)("li",{parentName:"ul"},"Transaction counter (8 bytes)"),Object(o.b)("li",{parentName:"ul"},"Signature (64 bytes)")),Object(o.b)("p",null,"The transaction is signed using the private key corresponding to the sender's account. Note that the sender's address is not ",Object(o.b)("em",{parentName:"p"},"explicitly")," included in the transaction. This is because it can be ",Object(o.b)("em",{parentName:"p"},"derived")," from this signature (using ",Object(o.b)("a",{parentName:"p",href:"https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work/18106"},"public key extraction")," applied to the EdDSA signature scheme)."),Object(o.b)("p",null,"The total size of a transaction is 108 bytes."),Object(o.b)("h3",{id:"syntactic-validity"},"Syntactic validity"),Object(o.b)("p",null,"Technically, any message that is 108 bytes long can be interpreted as a syntactically valid transaction. However, the transaction won't necessarily, ultimately be applied to the global state unless ",Object(o.b)("a",{parentName:"p",href:"#contextual-validity"},"certain conditions")," are met later."),Object(o.b)("h2",{id:"mining-transactions"},"Mining transactions"),Object(o.b)("h3",{id:"mempool-and-gossip"},"Mempool and gossip"),Object(o.b)("p",null,"Miners receive incoming, unprocessed transactions via the ",Object(o.b)("a",{parentName:"p",href:"/docs/protocol/p2p/overview"},"gossip network")," and locally over GRPC. When a miner receives a transaction, it checks that the transaction is valid and that it hasn't already seen the transaction before (i.e., it's not already in the mempool, nor in the mesh as part of at least one block)."),Object(o.b)("p",null,"The node next performs the following basic checks on the transaction:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Is it syntactically valid? (i.e., the right length)"),Object(o.b)("li",{parentName:"ul"},"Does the sender account exist, and contain a sufficient balance (>= the amount + fee)?"),Object(o.b)("li",{parentName:"ul"},"Is the transaction counter correct?")),Object(o.b)("p",null,"If these are all true, then the node saves the transaction into its mempool (each miner maintains its own mempool) and gossips it to the network. If not, then the transaction is rejected, is not added to the mempool, and is not gossiped."),Object(o.b)("p",null,"Note that the node considers other ",Object(o.b)("em",{parentName:"p"},"pending outgoing transactions"),' when performing this check. In other words, if Alice sends three transactions in a row, and none of them have been confirmed yet, they are only considered valid and added to the mempool if they have sequential transaction counters that start at the current counter value, and if none of the transactions "overdrafts" the account (including both the transaction amount and the fee). In particular, note that this calculation ',Object(o.b)("em",{parentName:"p"},"does not consider pending incoming transactions.")),Object(o.b)("h3",{id:"assembling-blocks"},"Assembling blocks"),Object(o.b)("p",null,"Each mining node is incentivized to include as many fee-paying transactions as possible into blocks that it assembles. Note that it is not trivial to determine which transactions will pay fees. This is because only transactions that are ",Object(o.b)("em",{parentName:"p"},Object(o.b)("a",{parentName:"em",href:"#contextual-validity"},"contextually valid")," in the instant when they're ",Object(o.b)("a",{parentName:"em",href:"#global-state"},"applied to the global state"))," pay fees (invalid transactions are discarded). Moreover, unlike in a blockchain, in Spacemesh a miner actually has no control over the final order of transactions in a layer. This is because the miner submits only a single block to the layer, and does not know the ultimate ",Object(o.b)("a",{parentName:"p",href:"#transaction-ordering"},"order of blocks and transactions")," in that layer. If another conflicting transaction appears before the transaction in question\u2014e.g., one that spends all of the funds in the sending account, or has the same transaction counter\u2014then the transaction in question may ultimately be deemed invalid, and discarded, without paying a fee."),Object(o.b)("p",null,"For the same reason, in Spacemesh, ",Object(o.b)("em",{parentName:"p"},"one invalid transaction does not invalidate a block.")),Object(o.b)("h2",{id:"applying-transactions"},"Applying transactions"),Object(o.b)("p",null,"The process of determining the current canonical state is simply the process of ordering and applying all of the transactions in the canonical mesh, in order. This process is explained in greater detail here."),Object(o.b)("p",null,"Transactions are applied one by one, in the order in which they appear in blocks, to the global state. Valid transactions cause the state to be updated. Of course, since Spacemesh defines a canonical ledger, the order in which transactions are applied is very important."),Object(o.b)("a",{name:"ordering"}),"### Transaction ordering",Object(o.b)("p",null,"Transaction order in Spacemesh is defined in the following way:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Blocks in layer ",Object(o.b)("em",{parentName:"li"},"n")," come before those in layer ",Object(o.b)("em",{parentName:"li"},"n+1")),Object(o.b)("li",{parentName:"ol"},"The IDs of all ",Object(o.b)("a",{parentName:"li",href:"/docs/protocol/consensus/overview#validity"},"contextually valid")," blocks in layer ",Object(o.b)("em",{parentName:"li"},"n")," are listed in ascending order"),Object(o.b)("li",{parentName:"ol"},"These block IDs are concatenated and hashed"),Object(o.b)("li",{parentName:"ol"},"The hash sum is used as the seed for a ",Object(o.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Mersenne_Twister"},"Mersenne Twister")," (a type of pseudorandom number generator)"),Object(o.b)("li",{parentName:"ol"},"A ",Object(o.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"},"Fisher-Yates shuffle")," is performed on the list of block IDs using the output of the Mersenne Twister"),Object(o.b)("li",{parentName:"ol"},"Transactions from the ordered blocks are then applied, in the order they appear in each block, ignoring duplicates (only the first appearance of a transaction determines its ordering)")),Object(o.b)("h3",{id:"contextual-validity"},"Contextual validity"),Object(o.b)("p",null,"A transaction is deemed contextually valid if, ",Object(o.b)("em",{parentName:"p"},"at the moment when a transaction is applied to the global state,")," the following conditions apply:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"The transaction appears in a ",Object(o.b)("a",{parentName:"li",href:"/docs/protocol/consensus/overview#block-validity-in-spacemesh"},"contextually valid block")),Object(o.b)("li",{parentName:"ol"},"The origin account (derived from the signature) exists"),Object(o.b)("li",{parentName:"ol"},"The counter on the account matches the transaction counter"),Object(o.b)("li",{parentName:"ol"},"The account balance is greater than or equal to the transaction amount + fee")),Object(o.b)("h3",{id:"global-state"},"Global state"),Object(o.b)("p",null,"The transactions in a given layer are applied to global state, ",Object(o.b)("a",{parentName:"p",href:"#ordering"},"in order"),", when that layer is finalized."),Object(o.b)("h4",{id:"finality"},"Finality"),Object(o.b)("p",null,"There are two stages of finalization in Spacemesh: the Hare and the Tortoise. A layer (and all of the transactions it includes) is applied to global state when the Hare protocol reaches consensus about it, usually within four minutes of when the blocks are produced. When the Tortoise reaches this layer later (depending on network parameters and conditions, this will usually be two layers later) it can reaffirm the output of the Hare or reverse its conclusion. In the latter case, both transactions and rewards are rolled back and reapplied based on the new set of valid blocks."),Object(o.b)("p",null,"In the future, self healing will also possibly cause a rollback, but this is not implemented yet."),Object(o.b)("p",null,"For more information on the consensus process, see ",Object(o.b)("a",{parentName:"p",href:"/docs/protocol/consensus/overview"},"Consensus"),"."),Object(o.b)("h4",{id:"state-transition-function"},"State transition function"),Object(o.b)("p",null,"The entire process of applying the transactions for a given layer is performed as a single, atomic database transaction. Transactions are applied by being passed through the following state transition function:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"The origin account balance is decremented by the transaction amount + fee"),Object(o.b)("li",{parentName:"ol"},"The recipient account balance is incremented by the transaction amount"),Object(o.b)("li",{parentName:"ol"},"The origin account transaction counter is incremented by one")),Object(o.b)("p",null,"After each pass over the list of transactions, another pass is performed on the remaining (unapplied) transactions, in the same order, until no transaction from the list can be applied. The worst case performance is ",Object(o.b)("inlineCode",{parentName:"p"},"O(N^2)"),", and the expected (i.e., non-malevolent) case is ",Object(o.b)("inlineCode",{parentName:"p"},"O(N)"),", where ",Object(o.b)("inlineCode",{parentName:"p"},"N")," is the number of transactions in the layer. (In fact, it's ",Object(o.b)("inlineCode",{parentName:"p"},"O(N*M)")," where ",Object(o.b)("inlineCode",{parentName:"p"},"M")," is the length of the longest chain of intra-layer dependencies. However, ",Object(o.b)("inlineCode",{parentName:"p"},"M")," is expected to be very small since a wallet should not create transactions that depend upon other transactions in the same layer.)"),Object(o.b)("p",null,"Fees are distributed to the miner at the same time, but using an independent state transition. This is because transaction fees are pooled per layer."),Object(o.b)("h3",{id:"fees-and-rewards"},"Fees and rewards"),Object(o.b)("p",null,"As in Bitcoin and other blockchain platforms, a Spacemesh transaction pays a fee to incentivize a miner to include the transaction in a block. However, fees and mining rewards work a bit differently in Spacemesh."),Object(o.b)("h4",{id:"mining-rewards"},"Mining rewards"),Object(o.b)("p",null,"Time in Spacemesh is divided into fixed-length units of time called ",Object(o.b)("a",{parentName:"p",href:"/docs/protocol/overview#spacemesh-basics"},"layers and epochs"),". An epoch consists of a fixed number of layers. Each layer is five minutes long and contains a set of blocks."),Object(o.b)("p",null,"The Spacemesh protocol distributes 50 Smesh (SMH) (subject to the Smesh minting schedule) to the miners who contributed blocks to each layer. The amount of the reward paid to each miner depends on the number of blocks contributed by that miner, and on the total number of blocks contributed in that layer. A miner that contributes more blocks receives more reward."),Object(o.b)("h4",{id:"transaction-fees"},"Transaction fees"),Object(o.b)("p",null,"Like the wait staff in a restaurant pooling tips, transaction fees in Spacemesh are also pooled per layer and evenly distributed to all miners who contributed blocks to the layer, proportional to how many (contextually valid) blocks they contributed."),Object(o.b)("h4",{id:"timing"},"Timing"),Object(o.b)("p",null,"Both mining rewards and fees are credited to miners as part of the same atomic database transaction where all transactions in a layer are applied."),Object(o.b)("h4",{id:"block-weights"},"Block weights"),Object(o.b)("p",null,"At present, both block rewards and fees are divided equally among all the published, ",Object(o.b)("a",{parentName:"p",href:"/docs/protocol/consensus/overview"},"contextually valid")," blocks in a layer: in other words, a miner that contributed four blocks (and was eligible to contribute at least four blocks) would receive precisely twice the reward and twice the fees for that layer as a miner who contributed (and was eligible to contribute) two."),Object(o.b)("p",null,"However, this is subject to change as Spacemesh adds support for ",Object(o.b)("em",{parentName:"p"},"block weights.")," Under the system of block weights, each miner will instead receive a share (of rewards and fees) based on the product of storage x ticks they declared in their ",Object(o.b)("a",{parentName:"p",href:"/docs/protocol/mining/activations"},"activation transaction (ATX)"),". This share is divided by the number of blocks they are ",Object(o.b)("em",{parentName:"p"},"expected")," (i.e., eligible) to produce during the entire epoch. Each contextually valid block they ultimately produce will grant them a portion of this share. (E.g., if a miner is eligible to produce 50 blocks during a given epoch, and only produces 25, it will receive only half of the share. The rest will be distributed among all published blocks along with the rest of the pool.)"))}d.isMDXComponent=!0},109:function(e,t,a){"use strict";a.d(t,"a",(function(){return h})),a.d(t,"b",(function(){return u}));var n=a(0),i=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=i.a.createContext({}),d=function(e){var t=i.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=d(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),h=d(a),b=n,u=h["".concat(r,".").concat(b)]||h[b]||p[b]||o;return a?i.a.createElement(u,s(s({ref:t},l),{},{components:a})):i.a.createElement(u,s({ref:t},l))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,r=new Array(o);r[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,r[1]=s;for(var l=2;l<o;l++)r[l]=a[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);