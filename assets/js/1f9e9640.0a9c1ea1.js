(self.webpackChunksm_platform_docs=self.webpackChunksm_platform_docs||[]).push([[806],{3905:function(e,t,a){"use strict";a.d(t,{Zo:function(){return p},kt:function(){return u}});var i=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=i.createContext({}),c=function(e){var t=i.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(a),u=n,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||o;return a?i.createElement(m,r(r({ref:t},p),{},{components:a})):i.createElement(m,r({ref:t},p))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,r[1]=s;for(var c=2;c<o;c++)r[c]=a[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6213:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return r},metadata:function(){return s},toc:function(){return l},default:function(){return p}});var i=a(2122),n=a(9756),o=(a(7294),a(3905)),r={id:"overview",title:"The Hare Protocol",sidebar_label:"Overview"},s={unversionedId:"protocol/hare/overview",id:"protocol/hare/overview",isDocsHomePage:!1,title:"The Hare Protocol",description:"Description",source:"@site/docs/protocol/hare/overview.md",sourceDirName:"protocol/hare",slug:"/protocol/hare/overview",permalink:"/docs/next/protocol/hare/overview",editUrl:"https://github.com/spacemeshos/platform-docs/blob/main/docs/protocol/hare/overview.md",version:"current",lastUpdatedBy:"Aviv Eyal",lastUpdatedAt:1615307334,formattedLastUpdatedAt:"3/9/2021",sidebar_label:"Overview",frontMatter:{id:"overview",title:"The Hare Protocol",sidebar_label:"Overview"},sidebar:"someSidebar",previous:{title:"As described in [Overview](01-overview.md), consensus in Spacemesh consists of two independent but complementary protocols, called the Tortoise and the Hare. This document provides more details and context on these protocols, explaining how they fit into the broader landscape of BFT consensus protocols, and why they're well-suited to the needs of Spacemesh.",permalink:"/docs/next/protocol/consensus/deepdive"},next:{title:"Hare Protocol FAQ",permalink:"/docs/next/protocol/hare/faq"}},l=[{value:"Description",id:"description",children:[]},{value:"Definitions",id:"definitions",children:[]},{value:"The Protocol",id:"the-protocol",children:[]},{value:"Eligibility Oracle",id:"eligibility-oracle",children:[{value:"Proof &amp; Validation",id:"proof--validation",children:[]}]},{value:"Message Validation &amp; Processing Flow",id:"message-validation--processing-flow",children:[{value:"Eligibility &amp; Signature Validation",id:"eligibility--signature-validation",children:[]},{value:"Contextual Validity",id:"contextual-validity",children:[]},{value:"Syntactic Validity",id:"syntactic-validity",children:[]}]}],c={toc:l};function p(e){var t=e.components,a=(0,n.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,i.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"description"},"Description"),(0,o.kt)("p",null,"The Hare protocol is a consensus protocol that achieves consensus on a set of values. In our case, we want to achieve consensus on a set of block ids (the set of values) in a specific layer (the instance/layer id)."),(0,o.kt)("p",null,"The general problem is the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Quantum_Byzantine_agreement"},"Byzantine Agreement Problem"),". Our protocol is based on the ",(0,o.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2018/1028.pdf"},"ADDNR18 paper")," and differs mainly on the fact that we want to achieve consensus on a set of values rather than a single value."),(0,o.kt)("p",null,"It is known in advance when an agreement process should start for each layer. On the other hand, the time it takes to achieve agreement can vary, depending on the number of faulty/malicious participants in the consensus. Hence, multiple consensus instances may be run concurrently.  "),(0,o.kt)("p",null,"On this page we will discuss the core protocol concepts and clarify it. Please note we do not intend to talk about the implementation itself, we might mention practical ways that overlap with it."),(0,o.kt)("h2",{id:"definitions"},"Definitions"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"N")," - The number of active participants"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"f")," - The number of active dishonest participants"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Pi")," - A participant in the consensus"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Si")," - The current set of values observed by Pi"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ISi")," - The initial set of Pi"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Round")," - the duration in which messages are sent and received. It is assumed by the protocol that messages that are sent (by honest) at the beginning of the round are received (by honest) no later than the end of that round. Since we are using the P2P to broadcast messages, it follows that the round duration is no less than the expected propagation in the P2P network."),(0,o.kt)("h4",{id:"byzantine-agreement-on-sets"},"Byzantine Agreement on Sets"),(0,o.kt)("p",null,"Parties {Pi} are said to achieve byzantine agreement on sets {Si} if three conditions are satisfied:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Consistency"),": Every honest party outputs the same set S'"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Validity 1")," (\u201call honest witnessed\u201d): If for every honest party Pi value v is in ISi then v is in S'"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Validity 2")," (\u201cno honest witness\u201d): If for no honest party Pi value v in ISi then v is not in S'. In other words, all values in S' should have had at least one honest witness."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Termination")," - All honest participants terminate with overwhelming probability.")),(0,o.kt)("h4",{id:"active-participants"},"Active Participants"),(0,o.kt)("p",null,"In each round, a new committee is selected randomly by the oracle (which we assume its existence).\nPicking a random committee over having all the nodes participate in the protocol is good for two main reasons:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Less participants means lower communication requirements."),(0,o.kt)("li",{parentName:"ol"},"Random election of participants means the participants are not predicted hence less likely to be exposed to DDOS attacks (for example).\nIn the proposal round, the expected number of participants is low (1 for example). In all other rounds we expect N (active) participants.")),(0,o.kt)("h4",{id:"commit-certificate---csk"},"Commit Certificate - C(S,K)"),(0,o.kt)("p",null,"A proof that consists of f+1 commit messages on the same set S for the same iteration K.\nf+1 commit messages implies at least one of them is honest and hence the set S is ensured to be valid."),(0,o.kt)("h4",{id:"safe-value-proof-svp"},"Safe Value Proof (SVP)"),(0,o.kt)("p",null,"The SVP is used to prove a proposal sent by the leader.\nThere are two types of SVP proofs, both consist of f+1 status messages:\nType A - assumes that no honest participant has committed to a set yet. In that case, any proposal is valid and we validate it by checking the validity of the status messages which are provable by the pre-round messages.\nType B - assumes an honest has already committed. From this moment, we know there is a certificate (the Commit Certificate) we should consider. We must Validate the certificate and check that the certificate is at least not older than the last certificate we know of."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"the-protocol"},"The Protocol"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Pre-Round"),"\nThe protocol begins with one ",(0,o.kt)("inlineCode",{parentName:"p"},"pre-round"),". This round is executed only once and its goal is to remove values which shouldn't be considered at all according to ",(0,o.kt)("inlineCode",{parentName:"p"},"Validity 2")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"At the beginning of the pre-round each active party sends his set of values ISi"),(0,o.kt)("li",{parentName:"ul"},"At the end of the pre-round, each value that hasn't received f+1 witnesses is removed. This ensures that we are left only with values that has at least one honest witness and therefore satisfying ",(0,o.kt)("inlineCode",{parentName:"li"},"validity 2"))),(0,o.kt)("p",null,"The protocol repeatedly iterates through up to 4 rounds until a consensus is reached."),(0,o.kt)("p",null,"Each round longs a constant time. A ",(0,o.kt)("inlineCode",{parentName:"p"},"Roles Oracle")," is used to generate roles in each round."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Status Round")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Active participants broadcast their current status to the network (S, k , ki)"),(0,o.kt)("li",{parentName:"ul"},"At the end of this round, a participant can form an SVP based on the statuses he collected during the round")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Proposal Round")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The leader can now give his proposal which provides a set T with the corresponding SVP P to the network"),(0,o.kt)("li",{parentName:"ul"},"Each participant can validate the proposition sent by the leader and consider that set T as a candidate of a set to commit on\nNote: we say candidate (opposed to accepted) since it is possible that the sender is malicious, sending more than one proposal during this round. We call it ",(0,o.kt)("strong",{parentName:"li"},"equivocation"),". During the following round we will be able to detect equivocation.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Commit Round")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Active participants announce their will to commit to the proposed set T by broadcasting (S, k, ki)"),(0,o.kt)("li",{parentName:"ul"},"At the end of the round, observing f+1 commit messages that indicate the set T implies at least one honest is willing to commit to T. This f+1 commit message can now form the certificate on the set T which is the proof that will be provided to the rest of the network in the following round."),(0,o.kt)("li",{parentName:"ul"},"If equivocation is detected by a party P, P doesn't commit to T.\nNote: accepted proposals must have been received no later than the end of the proposal round. Hence, any accepted proposal will arrive to all honest participants no later than this commit round and that is why we are ensured to detect equivocation.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Notify Round")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An (active) participant that were able to form a certificate at the end of the commit round, broadcasts a notify message which includes (S, k, ki, C(S, k))"),(0,o.kt)("li",{parentName:"ul"},"Upon receiving a valid notify message the participant updates his internal state according to the attached set")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Termination"),"\nIf at any point of the protocol, a participant P receives f+1 notify messages on the same set S, it commits to S and terminates.\nNote: it is hereby follows that all honest participants will receive f+1 notifications no later than the following round and hence will terminate also."),(0,o.kt)("h2",{id:"eligibility-oracle"},"Eligibility Oracle"),(0,o.kt)("p",null,"Eligibility to participate in a round (being active) is determined by the oracle mechanism.\nThe oracle is required to provide three main properties:\nA. Eligibility is under consensus - meaning all honest participant who receive a message will either classify it as active or as passive.\nB. The eligibility can be calculated in advance only up to some configurable limit of time before it can be used to participate.\nC. Eligibility is determined for each round in a layer separately and at random."),(0,o.kt)("h3",{id:"proof--validation"},"Proof & Validation"),(0,o.kt)("p",null,"The Threshold\nThresholding a random input can be used to determine eligibility. I.e. we can set the threshold a participant should pass in order to participate. For example, we can set a threshold of X participants over the space of a 32 bit uint which is simply X/2^32. Randomly picking numbers in ","[0,2^32-1]"," will result in an expected number of X participants passing the threshold and hence X actives."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Proof"),"\nA participant who wants to prove eligibility attaches the signature of the VRF message.\nThe VRF message is the tuple {agreed value, Layer, Round}. Signing the layer and the round is what ensures property C.\nThe value is provided by the Hare Beacon. It aims to ensure that the value is under consensus. I.e. all participants will use the same value (hence complying with property A). The value, for example, can be taken from some point in the past of the mesh which complies with property B.\nThe reason we use a VRF signature is that we want to make sure the signing process is not grindable. This is ensured by the property of VRF messages where each output has a single source."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Validation"),"\nIn order to validate the vrf message the receiver should:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Reconstruct the matching VRF message and check the signature against that message."),(0,o.kt)("li",{parentName:"ol"},"Validate the the hash of signature of the VRF message passes the threshold.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Leadership"),"\nThe leader eligibility is derived by the same process described above. The only difference is that the expected number of actives is set to 1. Since eligibility is random, it is possible that more than one leader will exist in the same (proposal) round. To handle this, we agree on a way to order the signatures in order to decide who is the real accepted leader. For example, this can be done by comparing bytes and accepting lowest ranked leader."),(0,o.kt)("h2",{id:"message-validation--processing-flow"},"Message Validation & Processing Flow"),(0,o.kt)("h3",{id:"eligibility--signature-validation"},"Eligibility & Signature Validation"),(0,o.kt)("p",null,"Each message received (no matter of what type) is checked for:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Validity of signature (the message signature)"),(0,o.kt)("li",{parentName:"ul"},"Validity of eligibility (the role proof signature and the threshold as specified under EligibilityOracle")),(0,o.kt)("p",null,"Note: messages that form a commit certificate or an SVP should also be validated for eligibility and signature."),(0,o.kt)("h3",{id:"contextual-validity"},"Contextual Validity"),(0,o.kt)("p",null,"A message M(TYPE, K) where K is the round counter (K%4 is the round K/4 is the iteration) is said to be contextually valid iff the receiver received the message on round K%4 of iteration K/4.\nFor example, a message of type status round should arrive during the status round and in addition if K=8 then the receiver should be in the second iteration.\nA message that arrives at the correct iteration but one round before the correct round is considered early.\nA late message is a contextually invalid message."),(0,o.kt)("h3",{id:"syntactic-validity"},"Syntactic Validity"),(0,o.kt)("p",null,"Syntax validity assures the structure of the message is correct. For example if it is a proposal message then it should include an SVP."),(0,o.kt)("h4",{id:"commit-certificate-validation"},"Commit Certificate Validation"),(0,o.kt)("p",null,"Reminder: a commit certificate is a collection of commit messages.\nValidations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"validate that all messages are of type commit"),(0,o.kt)("li",{parentName:"ul"},"validate that all (commit) messages state the same iteration number"),(0,o.kt)("li",{parentName:"ul"},"uniqueness of sender across all commit messages"),(0,o.kt)("li",{parentName:"ul"},"validate that all messages state the same set (in the implementation the set is optimized-out of the commit message and attached to the certificate only once)")),(0,o.kt)("h4",{id:"proposal--svp-validation"},"Proposal & SVP Validation"),(0,o.kt)("p",null,"Reminder: SVP consists of f+1 status messages.\nValidations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"validate all messages are of type status"),(0,o.kt)("li",{parentName:"ul"},"validate all (status) messages state the same iteration number"),(0,o.kt)("li",{parentName:"ul"},"uniqueness of sender across all commit messages"),(0,o.kt)("li",{parentName:"ul"},"for each status messsages(S, K , Ki):",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"if ki > 0 look for a certificate on (S,K)"),(0,o.kt)("li",{parentName:"ul"},"if ki = -1 prove by preround messages"))),(0,o.kt)("li",{parentName:"ul"},"Validate SVP type:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Type A - the proposal states the union of all status messages"),(0,o.kt)("li",{parentName:"ul"},"Type B - the proposal states the set S for which ki is maximal")))),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/spacemeshos/protocol/hare/hare/svg/msg_validation.svg?sanitize=true",alt:"Message Validation"}),"\n",(0,o.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/spacemeshos/protocol/hare/hare/svg/round1.svg?sanitize=true",alt:"Round 1"}),"\n",(0,o.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/spacemeshos/protocol/hare/hare/svg/round2.svg?sanitize=true",alt:"Round 2"}),"\n",(0,o.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/spacemeshos/protocol/hare/hare/svg/round3.svg?sanitize=true",alt:"Round 3"}),"\n",(0,o.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/spacemeshos/protocol/hare/hare/svg/round4.svg?sanitize=true",alt:"Round 4"})))}p.isMDXComponent=!0}}]);