(self.webpackChunksm_platform_docs=self.webpackChunksm_platform_docs||[]).push([[345],{3905:function(e,t,o){"use strict";o.d(t,{Zo:function(){return h},kt:function(){return d}});var a=o(7294);function n(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,n=function(e,t){if(null==e)return{};var o,a,n={},r=Object.keys(e);for(a=0;a<r.length;a++)o=r[a],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)o=r[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var o=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=c(o),d=n,m=u["".concat(l,".").concat(d)]||u[d]||p[d]||r;return o?a.createElement(m,i(i({ref:t},h),{},{components:o})):a.createElement(m,i({ref:t},h))}));function d(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=o.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var c=2;c<r;c++)i[c]=o[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,o)}u.displayName="MDXCreateElement"},3042:function(e,t,o){"use strict";o.r(t),o.d(t,{frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l},default:function(){return h}});var a=o(2122),n=o(9756),r=(o(7294),o(3905)),i={id:"deepdive",title:"Protocol Deep Dive",sidebar_label:"Deep Dive"},s={unversionedId:"protocol/consensus/deepdive",id:"protocol/consensus/deepdive",isDocsHomePage:!1,title:"As described in [Overview](01-overview.md), consensus in Spacemesh consists of two independent but complementary protocols, called the Tortoise and the Hare. This document provides more details and context on these protocols, explaining how they fit into the broader landscape of BFT consensus protocols, and why they're well-suited to the needs of Spacemesh.",description:"Tortoise",source:"@site/docs/protocol/consensus/02-deepdive.md",sourceDirName:"protocol/consensus",slug:"/protocol/consensus/deepdive",permalink:"/docs/next/protocol/consensus/deepdive",editUrl:"https://github.com/spacemeshos/platform-docs/blob/main/docs/protocol/consensus/02-deepdive.md",version:"current",lastUpdatedBy:"Aviv Eyal",lastUpdatedAt:1615307334,formattedLastUpdatedAt:"3/9/2021",sidebar_label:"Deep Dive",sidebarPosition:2,frontMatter:{id:"deepdive",title:"Protocol Deep Dive",sidebar_label:"Deep Dive"},sidebar:"someSidebar",previous:{title:"Consensus in Spacemesh",permalink:"/docs/next/protocol/consensus/overview"},next:{title:"The Hare Protocol",permalink:"/docs/next/protocol/hare/overview"}},l=[{value:"Tortoise",id:"tortoise",children:[{value:"How it works",id:"how-it-works",children:[]},{value:"Self-healing",id:"self-healing",children:[]},{value:"Weak coin beacon",id:"weak-coin-beacon",children:[]},{value:"Compared to other protocols",id:"compared-to-other-protocols",children:[]}]},{value:"Hare",id:"hare",children:[{value:"What does it give us?",id:"what-does-it-give-us",children:[]},{value:"Hare beacon",id:"hare-beacon",children:[]},{value:"Compared to HotStuff and Tendermint",id:"compared-to-hotstuff-and-tendermint",children:[]}]},{value:"Other Proof of Space-based protocols",id:"other-proof-of-space-based-protocols",children:[{value:"Chia",id:"chia",children:[]}]}],c={toc:l};function h(e){var t=e.components,o=(0,n.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"tortoise"},"Tortoise"),(0,r.kt)("p",null,"The Tortoise consensus mechanism was custom-designed to suit the needs of Spacemesh. It's a traditional Byzantine agreement protocol that adds a self-healing feature. It's based on previous work done on ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2017/300"},"Meshcash")," by Bentov, Hub\xe1\u010dek, Moran and Nadler."),(0,r.kt)("p",null,"The Tortoise protocol has three particularly important properties:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Consensus:")," it allows all nodes to achieve consensus (on the canonical set of blocks in each layer)"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Irreversibility:")," older history is harder to change than more recent history"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Self-healing:")," all nodes will eventually converge and achieve consensus even if they temporarily disagree")),(0,r.kt)("h3",{id:"how-it-works"},"How it works"),(0,r.kt)("p",null,"The Tortoise counts votes, cast in more recent blocks, for and against previous blocks. These votes indicate whether those previous blocks should be considered ",(0,r.kt)("a",{parentName:"p",href:"/docs/next/protocol/consensus/overview#block-validity-in-spacemesh"},"contextually valid"),", i.e., whether, from the perspective of the voter, the block was received on time. In most cases, the vast majority of honest nodes will agree on a given block's validity, and there will be an overwhelming number of votes cast for or against the block. In rare cases, such as in the case of a ",(0,r.kt)("a",{parentName:"p",href:"https://arxiv.org/abs/1612.09426"},"balancing attack"),", a block may not clearly cross either threshold."),(0,r.kt)("p",null,"Votes are processed per layer, and target around 800 votes per layer (this is in order to meet the network's ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Security_parameter"},"statistical security parameter")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"2^-40"),"; if layers are much smaller than this, they may be grouped together into larger ",(0,r.kt)("em",{parentName:"p"},"clusters"),'). If the votes are overwhelmingly positive or negative, e.g., net +600 in favor of a block ("This block is valid") or net -700 against a block ("This block did not arrive on time"), no additional work is needed to achieve consensus. If the net vote for a block is closer to zero, e.g., +100, then instead of voting based on what they observed, all honest nodes vote according to a coin flip. This is how the Tortoise achieves self-healing.'),(0,r.kt)("h3",{id:"self-healing"},"Self-healing"),(0,r.kt)("p",null,"Self-healing is the ability to converge, and to achieve consensus, even if nodes are in a state of initial disagreement, such as in case of a network partition or an attack. Self-healing takes time, and the exact amount of time it takes depends upon both protocol parameters (such as the properties of the beacon), as well as upon the proportion of honest nodes. If there are no attacking nodes for a long enough period of time (one cluster), then convergence should happen more or less instantly. Convergence is still possible even in the case of an ongoing partition or attack, but in this case it will take longer."),(0,r.kt)("p",null,"Note that, in order for self-healing to work, the Tortoise requires a greater than 2/3 honest majority. This is because the protocol works using votes, and there must be a large enough margin between honest and dishonest votes."),(0,r.kt)("p",null,"Self-healing works via a ",(0,r.kt)("em",{parentName:"p"},"separate byzantine agreement mechanism")," that does not depend on shared view of history."),(0,r.kt)("h3",{id:"weak-coin-beacon"},"Weak coin beacon"),(0,r.kt)("p",null,'The weak coin beacon uses a VRF-based protocol to generate a weak coin toss. In each round, each party calculates the output of a VRF based on their identity and the round number. Parties with a sufficiently low result publish their results and the lowest result wins. The value of the "coin toss" is one bit, e.g., the least significant bit, of this lowest result.'),(0,r.kt)("p",null,'If the lowest result comes from an honest participant, it will be published on time, everyone will receive this result, and all honest parties will agree on it. The "weak" nature of the coin comes from the fact that, in some cases, a dishonest adversary may win and be able to bias the results by, e.g., choosing not to publish their result, publishing it late, etc.'),(0,r.kt)("p",null,"In the case where all honest parties ",(0,r.kt)("em",{parentName:"p"},"do")," agree on the result of the coin toss, they will all adjust their next round of votes on the blocks in question ",(0,r.kt)("em",{parentName:"p"},"in the same direction"),' (e.g., "heads" means "vote yes"), and convergence will be achieved in the following round. In the case where an adversary successfully attacks the result, convergence will be delayed one round. Note that the honest parties only need to win this coin toss game once in order to achieve convergence, and over time the likelihood of this occurring only grows.'),(0,r.kt)("p",null,"Importantly, the beacon ",(0,r.kt)("em",{parentName:"p"},"does not rely upon any previous data")," and, thus, does not rely upon consensus having been previously achieved or maintained. This is what enables the self-healing property."),(0,r.kt)("p",null,"An astute reader will notice that, unlike, e.g., the Hare beacon, there is no random input to the beacon VRF, since the input is just a node's identity and the current round number. This means that an adversary can grind on this identity and could possibly generate many identities to give them an advantage in biasing the weak coin toss. This is an area of active research, but our current thinking is that we should allow grinding on VRF identities but make it expensive to do so."),(0,r.kt)("h3",{id:"compared-to-other-protocols"},"Compared to other protocols"),(0,r.kt)("p",null,'Blockchains based on Nakamoto consensus, such as Bitcoin, also have this "self-healing" property: some node will always produce the next block, and the ability to produce a new block doesn\'t depend upon consensus having been achieved in a prior round. In this way, over time all nodes will always converge around the "longest chain." However, it\'s much more difficult to achieve this property ',(0,r.kt)("em",{parentName:"p"},"without")," Proof of Work, as in the case of Spacemesh. This is because, in most BFT-style protocols, if the network loses consensus even briefly, it's impossible to re-establish consensus. In protocols with committees that nominate and notarize a committee for the following round, for instance, without agreement on the current committee, there's no way for the network to reach agreement on the next valid committee."),(0,r.kt)("p",null,"In a PBFT-style system, such as those based on HotStuff BFT, losing consensus in this manner might mean that different participants have a different view on which transactions are confirmed. Self-healing ensures that this cannot happen in Spacemesh."),(0,r.kt)("p",null,"Another important difference between the Tortoise and a BFT-style protocol is that the Tortoise is capable of a more robust form of consensus: even if assumptions fail for a while, things that have been in consensus for a while remain in consensus. Contrast this with a BFT-style protocol, where you cannot rely on history in such a scenario, since it can be reversed."),(0,r.kt)("h2",{id:"hare"},"Hare"),(0,r.kt)("p",null,"The Hare is a BFT algorithm based on ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2018/1028.pdf"},"ADDNR18"),", with the important difference that we want to achieve consensus on a set of values rather than a single bit value."),(0,r.kt)("h3",{id:"what-does-it-give-us"},"What does it give us?"),(0,r.kt)("p",null,"Because of the self-healing mechanism (described above), Spacemesh would function without the Hare. This is because self-healing guarantees that Spacemesh nodes will eventually converge and reach consensus from any starting condition, even without the initial, bootstrapped agreement that the Hare gives us. However, we would lose two things without the Hare:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Time:")," self-healing takes time."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Efficiency:")," the self-healing protocol is less efficient (measured in terms of both computational and communication complexity) than the Hare. We have put considerable work into optimizing the Hare to make it as efficient as possible.")),(0,r.kt)("p",null,"Depending on committee size the Hare can theoretically tolerate up to 1/2 malicious participants. This is because it takes advantage of strong synchrony assumptions. In practice, however, for efficiency purposes the Hare is parameterized to support up to approx. 800 participants with a 2/3 honest majority assumption. This is based on the aforementioned statistical security parameter."),(0,r.kt)("h3",{id:"hare-beacon"},"Hare beacon"),(0,r.kt)("p",null,"Eligibility to participate in each ",(0,r.kt)("a",{parentName:"p",href:"/docs/next/protocol/consensus/overview#rounds"},"round of the Hare protocol")," is based on the output of a VRF, which includes randomness from the Hare beacon. This makes it impossible for an adversary to grind on an identity and produce identities that would bias the results of the Hare too much, since they could only forecast Hare eligibility for a small number of future rounds."),(0,r.kt)("p",null,"The Hare has the advantage that it can rely on the Tortoise for its beacon, which makes it much simpler than the Tortoise beacon. We can use any value that honest parties are guaranteed to have previously agreed upon ",(0,r.kt)("em",{parentName:"p"},"even if the Hare isn't working,")," such as the set of block IDs from a previous layer that's sufficiently far back."),(0,r.kt)("p",null,"In the case of a network partition or attack, the Hare protocol may cease to work. It may not achieve a sufficient vote quorum or, in the extreme case, nodes may not even agree on the beacon value. In this case, the Hare will keep trying to run at every new layer until the Tortoise's self-healing mechanism achieves convergence, at which point the Hare will begin to function again."),(0,r.kt)("h3",{id:"compared-to-hotstuff-and-tendermint"},"Compared to HotStuff and Tendermint"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://arxiv.org/pdf/1803.05069.pdf"},"HotStuff")," requires a known set of participants (i.e., it does not support player replaceability), cannot be made permissionless, doesn't scale to thousands of participants, and does not easily convert to set agreement (i.e., agreement on a set of valus rather than on a single bit value). The requirement to have a known set of participants opens a DoS attack vector on known future participants."),(0,r.kt)("li",{parentName:"ul"},"HotStuff and Tendermint make different assumptions about network synchrony: they both assume a ",(0,r.kt)("em",{parentName:"li"},"partially-synchronous network"),' (i.e., there exists a "global stabilization time" after which all messages may be assumed to have been delivered, but you don\'t know exactly when this time is). The Hare, on the other hand, assumes a ',(0,r.kt)("em",{parentName:"li"},"fully-synchronous network,")," i.e., that all messages are delivered within a known period of time (which is specified as a protocol parameter, and affects layer time). As a result, HotStuff and Tendermint can make progress faster than Hare, but at the cost of having a lower corruption threshold: HotStuff and Tendermint both require a 2/3 honest majority, whereas the Hare requires only a simple honest majority."),(0,r.kt)("li",{parentName:"ul"},"HotStuff and Tendermint achieve a form of consensus known as ",(0,r.kt)("em",{parentName:"li"},"state machine replication"),' (SMR): this is a classical form of PBFT consensus where participants in the protocol agree upon an ordered sequence of transactions. The Hare protocol plays a different role in Spacemesh, and thus its goal is not to achieve SMR-style consensus. Rather, every time the Hare runs, its goal is to run for a finite number of rounds and achieve a "one-time agreement" on the set of valid blocks in the current layer, then terminate. Terminating an SMR-style consensus protocol is more difficult since it\'s unclear how to ensure that all participants have achieved precisely the same state\u2014indeed, these protocols are designed to run through an indefinite number of rounds.')),(0,r.kt)("h2",{id:"other-proof-of-space-based-protocols"},"Other Proof of Space-based protocols"),(0,r.kt)("h3",{id:"chia"},"Chia"),(0,r.kt)("p",null,"The Chia protocol aims to emulate Bitcoin and Nakamoto consensus more generally, but to replace Proof of Work with a novel mechanism called ",(0,r.kt)("a",{parentName:"p",href:"https://www.chia.net/assets/ChiaGreenPaper.pdf"},"Proof of Space"),'. In order to emulate the PoW lottery mechanism, Chia utilizes a VDF to create a "temporal lottery." Chia protocol and Spacemesh are only superficially related, in that both require commitment of space as a scarce resource. High-level differences include:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In Spacemesh, many blocks are produced at each layer, giving rise to its signature mesh (i.e., DAG) structure. Chia is a more traditional blockchain."),(0,r.kt)("li",{parentName:"ul"},"Chia requires stronger Proof of Space properties: a unique Proof of Space, and a VDF. By contrast, Spacemesh uses much weaker primitives: a ",(0,r.kt)("a",{parentName:"li",href:"/docs/next/protocol/mining/post"},"Proof of Spacetime")," (that isn't required to have a unique proof) and a Proof of Sequential Work (a.k.a. ",(0,r.kt)("a",{parentName:"li",href:"/docs/next/protocol/mining/poet"},"Proof of Elapsed Time"),", also not necessarily unique)."),(0,r.kt)("li",{parentName:"ul"},"Unlike Chia, Spacemesh is race free. Crucially, the slots in which a miner is eligible to produce blocks in Spacemesh do not depend on the proof of resource use. They're based solely on a miner's ID (plus a random input from a beacon), as described above.")))}h.isMDXComponent=!0}}]);