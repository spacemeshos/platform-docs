<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Spacemesh Platform Docs Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Spacemesh Platform Docs Blog Atom Feed"><title data-react-helmet="true">Mining - Proof of Space-time | Spacemesh Platform Docs</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="0.1.0"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-0.1.0"><meta data-react-helmet="true" property="og:title" content="Mining - Proof of Space-time | Spacemesh Platform Docs"><meta data-react-helmet="true" name="description" content="Proof of Space-Time (PoST) is a new cryptographic primitive, designed to replace Proof of Work (PoW) as a proof-of-resource-consumption scheme, and so as a Sybil-resistance mechanism for permissionless cryptocurrencies. It was introduced in 2016 by Tal Moran and Ilan Orlov in a paper titled Simple Proofs of Space-Time and Rational Proofs of Storage."><meta data-react-helmet="true" property="og:description" content="Proof of Space-Time (PoST) is a new cryptographic primitive, designed to replace Proof of Work (PoW) as a proof-of-resource-consumption scheme, and so as a Sybil-resistance mechanism for permissionless cryptocurrencies. It was introduced in 2016 by Tal Moran and Ilan Orlov in a paper titled Simple Proofs of Space-Time and Rational Proofs of Storage."><meta data-react-helmet="true" property="og:url" content="https://platform.spacemesh.io/docs/protocol/mining/post"><link data-react-helmet="true" rel="shortcut icon" href="/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://platform.spacemesh.io/docs/protocol/mining/post"><link rel="stylesheet" href="/styles.95c192fa.css">
<link rel="preload" href="/styles.911b1de1.js" as="script">
<link rel="preload" href="/runtime~main.10eef1c2.js" as="script">
<link rel="preload" href="/main.f41fa988.js" as="script">
<link rel="preload" href="/1.069955a3.js" as="script">
<link rel="preload" href="/39.5a542fb3.js" as="script">
<link rel="preload" href="/40.53bf907d.js" as="script">
<link rel="preload" href="/618c8e2f.8018f355.js" as="script">
<link rel="preload" href="/38.0dc0b0df.js" as="script">
<link rel="preload" href="/d3c8cfa3.a30bb4ea.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/favicon.png" alt="Spacemesh" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/favicon.png" alt="Spacemesh" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Spacemesh Platform</strong></a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link" href="/docs/">0.1.0</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/next/protocol/mining/post">Next</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/protocol/mining/post">0.1.0</a></li><li><a class="dropdown__link" href="/versions">All versions</a></li></ul></div></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">üåú</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">üåû</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/favicon.png" alt="Spacemesh" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/favicon.png" alt="Spacemesh" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Spacemesh Platform</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a role="button" class="menu__link menu__link--sublist">Versions</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/next/protocol/mining/post">Next</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/docs/protocol/mining/post">0.1.0</a></li><li class="menu__list-item"><a class="menu__link" href="/versions">All versions</a></li></ul></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">Welcome</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Protoocl</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol/p2p/overview">Peer to Peer</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Consensus</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/protocol/consensus/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/protocol/consensus/deepdive">Deep Dive</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Hare</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/protocol/hare/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/protocol/hare/faq">FAQ</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Mining</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol/mining/overview">Overview</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/protocol/mining/post">PoST</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol/mining/poet">PoET</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol/mining/activations">Activations</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol/sync/overview">Sync</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol/transactions/overview">Transactions</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">API</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/api/overview">Overview</a></li></ul></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><div><span class="badge badge--secondary">Version: 0.1.0</span></div><header><h1 class="docTitle_Oumm">Mining - Proof of Space-time</h1></header><div class="markdown"><p>Proof of Space-Time (PoST) is a new cryptographic primitive, designed to replace Proof of Work (PoW) as a proof-of-resource-consumption scheme, and so as a Sybil-resistance mechanism for permissionless cryptocurrencies. It was introduced in 2016 by <a href="https://talmoran.net/" target="_blank" rel="noopener noreferrer">Tal Moran</a> and <a href="https://www.cs.bgu.ac.il/~ilanorv/" target="_blank" rel="noopener noreferrer">Ilan Orlov</a> in a paper titled <a href="https://eprint.iacr.org/2016/035.pdf" target="_blank" rel="noopener noreferrer"><em>Simple Proofs of Space-Time and Rational Proofs of Storage</em></a>.</p><p>A PoST allows a prover to convince a verifier that they expended a certain amount of a ‚Äúspace-time‚Äù resource: a specific amount of space allocated over a specific time period, during which the space cannot be used for anything else. PoST requires significantly less energy than PoW, since the ‚Äúdifficulty‚Äù can be increased by extending the time period over which the space is allocated, without introducing additional ongoing computational work.</p><p>PoST is a two-phase protocol. In the first phase, the <em>initialization phase</em> (executed once), the prover commits to generate and store some data, derived from a specific seed. In the second phase, the <em>execution phase</em> (executed periodically), the prover proves that they still have access to the data at some particular point in time.</p><p>Unfortunately, the protocol does not allow a prover to prove they <em>stored</em> the data, since an adversary can instead store only the initial seed (which can be used to regenerate the data). To overcome this problem, generating the data involves computational work, which can be parameterized such that the cost of regenerating the data is much higher than the cost of simply storing it.</p><p>This leads to the definition of the PoST resource as a trade-off between space-time and computational work, where under reasonable cost assumptions, a rational user will always prefer to use the lower-cost space-time resource over computational work (while at the same time a non-rational user has greater cost and does not gain any advantage). It means that there may be a strategy which does not require a prover to expend space over time, but if the parameters are set correctly, this strategy will be significantly more expensive.</p><p>For this reason, using PoST in the context of a cryptocurrency, where profit is the main motive for participation, we can guarantee that rational users would prefer to use the space-time resource, so it can be claimed that the cryptocurrency is energy efficient. However, if the <em>initialization</em> cost became lower than the cost of storing the data due to fluctuation in the market price of compute power relative to storage, the protocol essentially devolves to PoW. To avoid that, a <em>market-based mechanism</em> can be used to determine the difficulty level, similar in spirit to the difficulty adjustment in PoW-based cryptocurrencies such as Bitcoin.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="proof-of-space-time-vs-proof-of-space"></a>Proof of Space-time vs. Proof of Space<a class="hash-link" href="#proof-of-space-time-vs-proof-of-space" title="Direct link to heading">#</a></h2><p>Two very similar proposals for Proof of Space, with similar intentions, have been previously published (<a href="http://dx.doi.org/10.1007/978-3-662-48000-7_29" target="_blank" rel="noopener noreferrer">1</a>, <a href="http://dx.doi.org/10.1007/978-3-319-10879-7_31" target="_blank" rel="noopener noreferrer">2</a>). Unlike Proof of Space, however, the PoST definition takes into account amortization attacks (using the same space resource for different proofs), rationality of using the space-time resource over CPU work, and an explicit time element (ensuring that the space is committed for a fixed length of time). Moreover, PoST uses a different and much simpler technique, which explicitly allows a space-time tradeoff, and only relies upon the security of cryptographic hash functions.</p><p>Unlike existing Proof of Space constructions, the computational difficulty of the PoST initialization phase can be adjusted without linearly increasing either the required amount of space or the cost of verifying the proof. Hence it is possible to use it to prove that a reasonable amount of storage has been committed over a long period of time. In addition, in the case of an adjustment in difficulty (due to CPU and storage market relative price fluctuation), PoST supports simple, incremental difficulty adjustment‚Äîthat is, already-initialized users only have to pay the marginal work cost between difficulty levels, instead of rerunning the entire initialization phase from scratch. A downside of PoST is that the prover must read its entire storage for every proof, so the algorithm requires linear time, while in Proof of Space this is not required, so the algorithm runs in polylog time. This makes Proof of Space suitable for producing proofs in short intervals (e.g., every 10 seconds), while PoST is suitable for longer intervals (e.g., weeks or even months).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="construction"></a>Construction<a class="hash-link" href="#construction" title="Direct link to heading">#</a></h2><p>To allow public verifiability, and to ensure that the data generated in the initialization phase is cheaper to store than to regenerate, generating this data must entail Proof of Work. To avoid the prover having to send all of the data to the verifier, the prover doesn‚Äôt construct one large proof, but rather a table containing many entries, where each entry is a PoW that can be independently verified.</p><a name="phases"></a>### Phases<ul><li><strong>Initialization</strong>: the prover performs computational work that results in a dataset, generated with respect to a specific seed, organized as table entries. The seed may be a public key, so that an adversary which does not hold the corresponding private key cannot claim custody over the same data.</li><li><strong>Execution</strong>: Given a challenge, the prover generates a proof that they have access to the data generated in the initialization phase. The challenge (i.e., the subset of data that it refers to) should be unpredictable in order to make sure that the prover stores the entire data, and not only those parts needed for the proof.</li></ul><p><strong>The execution phase can be repeated multiple times</strong> without rerunning the initialization phase. This point is critical, since the initialization phase requires work, while the execution phase is energy efficient (i.e., it requires relatively few computational steps). Thus, although using PoST to generate a single proof does not give any advantage over PoW, using it to generate many such proofs allows the work required during the initialization phase to be amortized over all of the proofs, which makes the construction energy efficient.</p><a name="proving"></a>### Proving<p>Proving occurs at the end of the initialization phase (using an empty challenge), and on every subsequent iteration of the execution phase (as a response to a received challenge). This makes proving interactive between the prover and a verifier, except during the initialization phase, where the challenge is empty and, thus, non-interactive.</p><p>The <em>time</em> element of the space-time resource is the elapsed time between successive phases of generating the PoST proof. Each PoST proof refers to the previous proof, i.e., the proofs are chained (not unlike the way in which each Bitcoin block refers to the previous block). The first proof points to the initialization phase proof (akin to a genesis block). In this fashion, two sequential proofs which each independently attest to the data having been available for, say, one week, can be chained together to prove that the prover had the data for two full weeks. For more information on how the <em>elapsed time</em> component can be proven in a similar fashion, see the next section on <a href="/docs/protocol/mining/poet">Proof of Elapsed Time</a>.</p><p>To generate a proof, the prover commits to the data by constructing a Merkle tree whose leaves contain the data generated during the initialization phase (i.e., one or more of the generated table entries). Each internal node in the tree contains the output of a hash function on the concatenation of its children, salted with the challenge. This forces the prover to commit to their knowledge of the leaves (i.e., all of the data) at the time they generate the proof.</p><p>Once constructed, the prover needs to provide Merkle proofs (paths) to the root of the tree for a random set of, e.g., 100 entries, which serve as a <em>challenge.</em> The indices for these entries can be selected by the verifier as a response to the prover commitment (Merkle root). However, such an algorithm requires back-and-forth, interactive communication between the prover and the verifier, and as such is not practicable for use in a production blockchain protocol, which requires that <em>anyone</em> can publicly, independently verify a proof in a <em>non-interactive fashion.</em> This is accomplished by using the <a href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic" target="_blank" rel="noopener noreferrer">Fiat-Shamir heuristic</a>: the Merkle root hash is used to deterministically derive the random set of indices, i.e., the challenge. (Note that, as presented here, the <em>execution phase</em> still requires interaction since the PoST proof must be generated in response to a received, unpredictable challenge; see <a href="/docs/protocol/mining/nipost">NIPoST</a> for an explanation of how this is also made non-interactive.)</p><p>The prover cannot merely generate the data for the selected entries and skip all others, because they are forced to commit to the entire table and to a specific Merkle root before the challenge indices are known. If they happened to ‚Äúskip‚Äù an entry which will end up being selected, the proof would be invalid. This means that the prover is forced to either generate a large fraction of the table, or spend a lot of computational work trying to find a Merkle root that will produce a ‚Äúgood‚Äù set of indices. By setting the parameters correctly, we ensure that in the second case the amount of work the prover must do is more than the initialization cost.</p><p>The publicly-verifiable proof contains the Merkle root, the data for the selected entries from the PoW initialization phase, and their Merkle proofs. Common labels from the random set of distinct Merkle paths are eliminated to compress the proof.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="verifying"></a>Verifying<a class="hash-link" href="#verifying" title="Direct link to heading">#</a></h3><p>The verifier first derives the same set of indices (the challenge), similarly to the prover, using the Fiat-Shamir heuristic. Then she computes the Merkle root from the commitment Merkle proofs to verify that it matches the expected root value. Then she extracts the chosen entries from the proven leaves (each containing a group of entries), and verifies that the PoW is valid for their respective indices and seed.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="why-generic-pow-isnt-sufficient"></a>Why generic PoW isn‚Äôt sufficient<a class="hash-link" href="#why-generic-pow-isnt-sufficient" title="Direct link to heading">#</a></h2><p>Generating the data in the initialization phase involves computational PoW, but the standard definitions of PoW do not rule out an adversary that can store a small amount of data and use it to regenerate the entire data set with very low computational overhead (i.e., generate a large dataset, then compress it, and decompress it later). Thus, to ensure the prover must indeed store the entire data set, the protocol is constructed using <em>incompressible proof-of-work</em> (IPoW), a more restrictive variant of PoW that ensures that the prover cannot store compressed data, nor can they ‚Äúcompress‚Äù the required work to generate those data (i.e., perform less work).</p><p>The most popular form of PoW, the Hash-Preimage PoW, was introduced in <a href="http://www.hashcash.org/papers/hashcash.pdf" target="_blank" rel="noopener noreferrer">Hashcash</a> and is currently used in Bitcoin and Ethereum. It involves finding a certain value (called a nonce) that, when added to some fixed data (e.g., the contents of a block, known here as the <em>preimage</em>) and hashed, satisfies a certain difficulty criteria. This is not yet an incompressible PoW: although compressing the hash output is impossible, compressing the preimage isn‚Äôt.</p><p>However, the Hash-Preimage IPoW sets an upper limit on the amount of storage we can fill for a given initialization cost (number of hashes): with a predetermined sequence of values, one just needs to store a single bit for each item, indicating whether the item is a ‚Äúgood‚Äù preimage or not. Thus, due to the compression scheme, each hash invocation can ‚Äúcontribute‚Äù at most a single bit to the total storage.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="the-partial-hash-ipow"></a>The Partial-Hash IPoW<a class="hash-link" href="#the-partial-hash-ipow" title="Direct link to heading">#</a></h3><p>In order to be able to fill more space without increasing the initialization cost, a different IPoW is needed. <em>Partial-Hash IPoW</em> is a simple solution where the amount of work for every IPoW is always a single hash invocation, but the amount of storage the hash output would fill is adjustable (from one bit up to the entire output length). It is considered incompressible because, although the hash input might be smaller than the storage the output fills, the required CPU work for regenerating the output cannot be made cheaper, since it is already just a single hash invocation.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="post-deterministic-nature"></a>PoST deterministic nature<a class="hash-link" href="#post-deterministic-nature" title="Direct link to heading">#</a></h3><p>The entire PoST construction, from the Partial-Hash IPoW for generating the data to the Merkle tree commitment and proofs, is completely deterministic: e.g., the number of required hash invocations for any given space-time resource is known in advance. This makes PoST different in nature from PoW, where successfully generating a proof is probabilistic. In contrast, PoST allows us to guarantee that anyone spending the required resources is eligible to produce a valid proof. Thus PoST can be used to replace the lottery-based mechanism for block production (and so for rewards) in PoW with a deterministic one, meaning that leader-election is not a required part of the consensus protocol, enabling a <a href="https://spacemesh.io/race-freeness/" target="_blank" rel="noopener noreferrer">race-free cryptocurrency protocol</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="what-about-time"></a>What about time?<a class="hash-link" href="#what-about-time" title="Direct link to heading">#</a></h2><p>As presented above, the PoST construction allows a prover to assert, deterministically and verifiably in a non-interactive fashion, that they have generated and have access to a particular dataset derived from a known seed based on their unique ID. Where does the ‚Äútime‚Äù component derive from? In other words, how does the prover assert, in the same fashion, that they not only performed the initial generation of this dataset, but that they still have access to this data over time?</p><p>The next section, <a href="/docs/protocol/mining/poet">Proof of Elapsed Time</a>, expands upon the explanation above and explains in detail how this part works.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/spacemeshos/platform-docs/blob/main/versioned_docs/version-0.1.0/protocol/mining/02-post.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-03-09T19:07:34.000Z" class="docLastUpdatedAt_1Qna">3/9/2021</time> by <strong>Aviv Eyal</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/protocol/mining/overview"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">¬´ Mining Overview</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/protocol/mining/poet"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Mining - Proof of Elapsed Time ¬ª</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#proof-of-space-time-vs-proof-of-space" class="table-of-contents__link">Proof of Space-time vs. Proof of Space</a></li><li><a href="#construction" class="table-of-contents__link">Construction</a><ul><li><a href="#verifying" class="table-of-contents__link">Verifying</a></li></ul></li><li><a href="#why-generic-pow-isnt-sufficient" class="table-of-contents__link">Why generic PoW isn‚Äôt sufficient</a><ul><li><a href="#the-partial-hash-ipow" class="table-of-contents__link">The Partial-Hash IPoW</a></li><li><a href="#post-deterministic-nature" class="table-of-contents__link">PoST deterministic nature</a></li></ul></li><li><a href="#what-about-time" class="table-of-contents__link">What about time?</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Explore</h4><ul class="footer__items"><li class="footer__item"><a href="https://spacemesh.io/testnet" target="_blank" rel="noopener noreferrer" class="footer__link-item">Testnet</a></li><li class="footer__item"><a href="https://spacemesh.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Web</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="http://chat.spacemesh.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/teamspacemesh" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/spacemeshos" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2021 Spacemesh. This work is licensed under CC BY 4.0.</div></div></div></footer></div>
<script src="/styles.911b1de1.js"></script>
<script src="/runtime~main.10eef1c2.js"></script>
<script src="/main.f41fa988.js"></script>
<script src="/1.069955a3.js"></script>
<script src="/39.5a542fb3.js"></script>
<script src="/40.53bf907d.js"></script>
<script src="/618c8e2f.8018f355.js"></script>
<script src="/38.0dc0b0df.js"></script>
<script src="/d3c8cfa3.a30bb4ea.js"></script>
</body>
</html>