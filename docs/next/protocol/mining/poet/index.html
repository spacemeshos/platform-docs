<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Spacemesh Platform Docs Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Spacemesh Platform Docs Blog Atom Feed"><title data-react-helmet="true">Mining - Proof of Elapsed Time | Spacemesh Platform Docs</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Mining - Proof of Elapsed Time | Spacemesh Platform Docs"><meta data-react-helmet="true" name="description" content="Proof of Elapsed Time, or PoET, is a cryptographic primitive used to prove that a specific amount of real (clock) time has elapsed. Elapsed time is measured by iterating a sequential work cycle that takes a set amount of time to execute. The algorithm provides a proof that it has worked sequentially for a predetermined number of cycles, and thus proves that the period of time determined by its parameters has elapsed during its entire execution. By committing to knowledge of some information (known as a &quot;statement&quot;) as input to the proof-generation algorithm, a prover can assert cryptographically that they had knowledge of that information as of a given point in time."><meta data-react-helmet="true" property="og:description" content="Proof of Elapsed Time, or PoET, is a cryptographic primitive used to prove that a specific amount of real (clock) time has elapsed. Elapsed time is measured by iterating a sequential work cycle that takes a set amount of time to execute. The algorithm provides a proof that it has worked sequentially for a predetermined number of cycles, and thus proves that the period of time determined by its parameters has elapsed during its entire execution. By committing to knowledge of some information (known as a &quot;statement&quot;) as input to the proof-generation algorithm, a prover can assert cryptographically that they had knowledge of that information as of a given point in time."><meta data-react-helmet="true" property="og:url" content="https://platform.spacemesh.io/docs/next/protocol/mining/poet"><link data-react-helmet="true" rel="shortcut icon" href="/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://platform.spacemesh.io/docs/next/protocol/mining/poet"><link rel="stylesheet" href="/styles.457accf9.css">
<link rel="preload" href="/styles.286d6e86.js" as="script">
<link rel="preload" href="/runtime~main.90e08797.js" as="script">
<link rel="preload" href="/main.6d664d05.js" as="script">
<link rel="preload" href="/1.a65124db.js" as="script">
<link rel="preload" href="/39.6a5733e2.js" as="script">
<link rel="preload" href="/40.53bf907d.js" as="script">
<link rel="preload" href="/935f2afb.b0ccca47.js" as="script">
<link rel="preload" href="/38.0dc0b0df.js" as="script">
<link rel="preload" href="/6290580e.1190a3c4.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/favicon.png" alt="Spacemesh" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/favicon.png" alt="Spacemesh" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Spacemesh Platform</strong></a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link" href="/docs/next/">Next</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/next/protocol/mining/poet">Next</a></li><li><a class="dropdown__link" href="/docs/protocol/mining/poet">0.1.0</a></li><li><a class="dropdown__link" href="/versions">All versions</a></li></ul></div></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/favicon.png" alt="Spacemesh" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/favicon.png" alt="Spacemesh" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Spacemesh Platform</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a role="button" class="menu__link menu__link--sublist">Versions</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/docs/next/protocol/mining/poet">Next</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/protocol/mining/poet">0.1.0</a></li><li class="menu__list-item"><a class="menu__link" href="/versions">All versions</a></li></ul></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Platform</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/">Welcome</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Protoocl</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/protocol/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/protocol/p2p/overview">Peer to Peer</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Consensus</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/protocol/consensus/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/protocol/consensus/deepdive">Deep Dive</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Hare</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/protocol/hare/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/protocol/hare/faq">FAQ</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Mining</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/protocol/mining/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/protocol/mining/post">PoST</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/next/protocol/mining/poet">PoET</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/protocol/mining/activations">Activations</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/protocol/sync/overview">Sync</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/next/protocol/transactions/overview">Transactions</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">API</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/next/api/overview">Overview</a></li></ul></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="alert alert--warning margin-bottom--md" role="alert"><div>This is unreleased documentation for Spacemesh Platform Docs <strong>Next</strong> version.</div><div class="margin-top--md">For up-to-date documentation, see the <strong><a href="/docs/protocol/mining/poet">latest version</a></strong> (0.1.0).</div></div><div class="docItemContainer_a7m4"><article><div><span class="badge badge--secondary">Version: Next</span></div><header><h1 class="docTitle_Oumm">Mining - Proof of Elapsed Time</h1></header><div class="markdown"><p>Proof of Elapsed Time, or PoET, is a cryptographic primitive used to prove that a specific amount of real (clock) time has elapsed. Elapsed time is measured by iterating a sequential work cycle that takes a set amount of time to execute. The algorithm provides a proof that it has worked sequentially for a predetermined number of cycles, and thus proves that the period of time determined by its parameters has elapsed during its entire execution. By committing to knowledge of some information (known as a &quot;statement&quot;) as input to the proof-generation algorithm, a prover can assert cryptographically that they had knowledge of that information as of a given point in time.</p><p>In the context of Spacemesh, PoET is used to introduce the concept of <em>time</em> to the eligibility proofs submitted by miners by measuring the time interval between two executions of the <a href="/docs/next/protocol/mining/post">PoST algorithm</a>. In effect, PoET allows a miner to assert not only that they previously generated a set of data (the initialization phase of PoST), but that they still have access to that data after some time has elapsed (the execution phase)—hence, proofs of <em>space-time.</em></p><p>A naive cryptographic approach to proving elapsed time is proof of work, i.e., using computational effort spent as a proxy for elapsed time. But while proof of work attests to a certain amount of computational work having been performed, it does not strictly correspond to elapsed clock time, since the work may be parallelized. Thus in order to prove elapsed time we must use a construction that requires <em>inherently sequential work</em>, i.e., where each unit of work depends upon the output of the previous unit, so that parallelization could not reduce the duration taken to complete the work (while still being bound to a single-core CPU speed, which can vary, but has a practical limit). This sort of construction is sometimes referred to as Proof of Sequential Work (PoSW), which can be used as a proxy for Proof of Elapsed Time (PoET).</p><p>The underlying idea is that it’s extremely hard to make the computation of an iterated sequence of hashes faster then the fastest consumer-grade CPU, in particular if we use a hash function (such as SHA256) that mainstream CPU makers have already spent considerable resources accelerating. This is in sharp contrast to increasing <em>total work throughput</em> (i.e., the sort of work required by most computationally intensive applications), which can be done by parallelizing the work.</p><p>PoSW was first introduced in a 2013 paper by Mohammad Mahmoody, Tal Moran and Salil P. Vadhan (<a href="https://eprint.iacr.org/2011/553" target="_blank" rel="noopener noreferrer">MMV13</a>). It is a protocol for proving that one performed <em>sequential</em> computational work related to some statement, such that a minimum amount of time has passed since that statement became known to the actor performing the work (with a proof that’s publicly and efficiently verifiable). The initial motivation for such proofs was not blockchain designs but rather applications including document timestamping and universally verifiable CPU benchmarks. The construction of MMV13 is based on “depth-robust” graphs, which are designed to be memory hard (i.e., requiring not only a large amount of time but also a large amount of space to create a proof), making it impractical to use in a production blockchain.</p><p>A much simpler and more efficient construction was introduced in 2018 by Bram Cohen and Krzysztof Pietrzak (<a href="https://eprint.iacr.org/2018/183" target="_blank" rel="noopener noreferrer">CP18</a>), winning the best paper award in Eurocrypt that year. It replaces the MMV13 depth-robust graph with a graph based on a Merkle tree. The Spacemesh protocol uses an open source <a href="https://github.com/spacemeshos/poet" target="_blank" rel="noopener noreferrer">implementation</a> of the CP18 spec.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="construction"></a>Construction<a class="hash-link" href="#construction" title="Direct link to heading">#</a></h2><p>Unlike the PoST construction, PoET construction occurs in a single phase. At the very highest level of abstraction, it involves the first party, the prover, running an arbitrary, agreed-upon piece of information (known as the “statement”) through an agreed-upon hash function for an agreed-upon period of time (<em>t,</em> which in practice species the depth of the graph that&#x27;s generated, where a larger graph results in more repetitions of the hash function, as a proxy for elapsed wall time). The prover then generates a proof based on the results and publishes it for anyone to independently verify. As with PoST, and as described further in <a href="https://eprint.iacr.org/2018/183" target="_blank" rel="noopener noreferrer">CP18</a>, PoET is made non-interactive, enabling independent verification of the proof, via the use of Fiat-Shamir. Read on to better understand the protocol.</p><a name="algorithm"></a>### Non-interactive protocol<ol><li>All parties, including anyone who will independently verify generated proofs, agree on set of shared parameters, including the designated period of time, <em>t</em> (i.e., the depth of the graph), and the number of leaves to be included in a proof</li><li>Prover receives a statement, then using the statement as input runs the hash function for <em>t</em> time, i.e., generates a graph of a specified depth, calculates a commitment to that graph (Merkle root), derives the challenge from the commitment (using the <a href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic" target="_blank" rel="noopener noreferrer">Fiat-Shamir heuristic</a>), generates a proof (a set of labels and Merkle paths corresponding to the derived challenge). Publishes statement, Merkle root, and proof.</li><li>Verifier independently derives the challenge from the Merkle root (using the Fiat-Shamir heuristic), verifies the proof. If accepted, verifier is convinced that <em>t</em> time has passed since statement was learned by the prover. (See the next section for more information on how this happens.)</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="further-details"></a>Further details<a class="hash-link" href="#further-details" title="Direct link to heading">#</a></h3><p>The algorithm described above still leaves out some important details for the sake of readability and clarity, including the details of how verification works, as well as further details about how the graph is constructed in a <em>sequential</em> fashion.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="verification"></a>Verification<a class="hash-link" href="#verification" title="Direct link to heading">#</a></h4><p>The verifier first uses Fiat-Shamir to derive the deterministic challenge based on the Merkle root that the prover committed to (as in PoST), i.e., a random set of leaf indices. She then verifies that the proof contains the correct number of Merkle paths and that the set of Merkle paths matches the committed-to Merkle root. Finally, she independently runs the hash function to recompute the labels for the chosen leaves to make sure that they match the values contained in the proof.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="sequential-graph-construction"></a>Sequential graph construction<a class="hash-link" href="#sequential-graph-construction" title="Direct link to heading">#</a></h4><p>In order to construct the graph (a directed acyclic graph, or DAG), the label of each leaf node is the hash of the concatenation of the list of its left siblings on the path to the root node (this is what makes the work <em>sequential</em>), salted with the statement (this is how the prover proves knowledge of the statement before beginning the algorithm). The label of each intermediate node is the hash of the concatenation of its children (left and then right), salted with the statement. For more details on the algorithm, see the <a href="https://eprint.iacr.org/2018/183" target="_blank" rel="noopener noreferrer">CP18</a> paper and the open source <a href="https://github.com/spacemeshos/poet" target="_blank" rel="noopener noreferrer">implementation</a>.</p><p><img alt="Visualization of PoET graph construction" src="/assets/images/poet-dag-7d1cb9e30035d07275419afd62d31334.png" title="Visualization of PoET graph construction"></p><p>Construction of the DAG</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="poet-service"></a>PoET Service<a class="hash-link" href="#poet-service" title="Direct link to heading">#</a></h2><p>Miners are not expected to perform the sequential work themselves, as this would contradict one of the main goals of the Spacemesh protocol, energy efficiency, since it would require continuous CPU work.</p><p>The trick is that <em>a single PoET instance can be shared among an arbitrary number of miners,</em> so the amortized CPU cost drops as the number of miners utilizing a given PoET service grows. Since what’s needed is merely a proof that a certain amount of time has elapsed, proving that <em>someone</em> did sequential work is sufficient: the work does not have to have been performed by the miner itself!</p><p>In Spacemesh, a single PoET service is sufficient to provide a proof on behalf of many miners. Each of these miners can independently, efficiently verify the correctness of the output of the service.</p><p>A miner registers with a public PoET service by submitting their input (a hash of a challenge constructed using their previous <a href="/docs/next/protocol/mining/activations">ATX</a>, which contains their previous PoST) during the window advertised by the service. The service then creates a graph based on a Merkle tree whose leaves are the aggregate inputs from each miner, uses the root of the tree as the input (statement), runs the PoSW algorithm, and outputs a single, shared PoET proof that can be used by any of the registered miners.</p><p>In addition to the non-interactive proof whose input is the Merkle root of this graph created on the aggregate input (the “statement,” in the <a href="#algorithm">algorithm laid out above</a>), the PoET service can also provide Merkle paths from specific leaves (i.e., specific miner inputs) to that Merkle root. This allows individual miners to verify to themselves, and prove to others, that their input was included.</p><p>However, in Spacemesh, since many miners in practice share a single proof, it would be redundant for them each to publish an individual Merkle proof (i.e., it would be a waste of mesh storage space). There is another, more efficient way of establishing that every miner input is an element of the Merkle root (statement), and so validated by the shared proof: the PoET service itself broadcasts the <em>ordered list of all miner inputs</em> to the Spacemesh network via a Spacemesh-compatible gateway node (i.e., a node running a Spacemesh full node). Any verifier can then independently verify that each miner&#x27;s proof is valid, i.e., that its input was included in a given PoET run.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="chaining-post-and-poet"></a>Chaining PoST and PoET<a class="hash-link" href="#chaining-post-and-poet" title="Direct link to heading">#</a></h2><p>The last section, <a href="/docs/next/protocol/mining/post">Proof of Space-time</a>, explained how a prover can assert in a deterministic, independently verifiable, non-interactive fashion that they generated and still have access to a particular dataset derived from a known seed, based on their unique ID. This section explains how a prover can assert, in the same fashion, that a specific amount of objective time (measured using repetitions of an agreed-upon algorithm as a proxy for time) has passed since they had knowledge of a statement. The next section, <a href="/docs/next/protocol/mining/nipost">Non-interactive Proof of Space-time</a>, ties these two ideas together and explains how PoST and PoET proofs can be chained to assert <em>ongoing</em> commitment to the dataset for an arbitrarily long period of time.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/spacemeshos/platform-docs/blob/main/docs/protocol/mining/03-poet.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-03-09T16:28:54.000Z" class="docLastUpdatedAt_1Qna">3/9/2021</time> by <strong>Aviv Eyal</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/next/protocol/mining/post"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Mining - Proof of Space-time</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/next/protocol/mining/activations"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Mining - Activations »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#construction" class="table-of-contents__link">Construction</a><ul><li><a href="#further-details" class="table-of-contents__link">Further details</a></li></ul></li><li><a href="#poet-service" class="table-of-contents__link">PoET Service</a></li><li><a href="#chaining-post-and-poet" class="table-of-contents__link">Chaining PoST and PoET</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://discordapp.com/invite/spacemesh" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/teamspacemesh" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/spacemeshos" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Spacemesh. This work is licensed under CC BY 4.0.</div></div></div></footer></div>
<script src="/styles.286d6e86.js"></script>
<script src="/runtime~main.90e08797.js"></script>
<script src="/main.6d664d05.js"></script>
<script src="/1.a65124db.js"></script>
<script src="/39.6a5733e2.js"></script>
<script src="/40.53bf907d.js"></script>
<script src="/935f2afb.b0ccca47.js"></script>
<script src="/38.0dc0b0df.js"></script>
<script src="/6290580e.1190a3c4.js"></script>
</body>
</html>