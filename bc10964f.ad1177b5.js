(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{100:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return r})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(3),o=n(7),i=(n(0),n(113)),s={id:"overview",title:"Sync",sidebar_label:"Sync"},r={unversionedId:"protocol/sync/overview",id:"protocol/sync/overview",isDocsHomePage:!1,title:"Sync",description:"In order for a node to fully participate in the Spacemesh protocol, including the Consensus protocol, it is essential that the node be aware of the current state of the network. This includes knowing the current layer and epoch, the latest blocks and transactions, and the current set of eligible miners. (Other aspects of the protocol, such as the canonical ledger and the global state, are things the node can work out for itself based on these data.)",source:"@site/docs/protocol/sync/01-overview.md",slug:"/protocol/sync/overview",permalink:"/docs/next/protocol/sync/overview",editUrl:"https://github.com/spacemeshos/platform-docs/blob/main/docs/protocol/sync/01-overview.md",version:"current",lastUpdatedBy:"Aviv Eyal",lastUpdatedAt:1615308507,sidebar_label:"Sync",sidebar:"someSidebar",previous:{title:"Mining - Activations",permalink:"/docs/next/protocol/mining/activations"},next:{title:"Transactions",permalink:"/docs/next/protocol/transactions/overview"}},c=[{value:"Getting data",id:"getting-data",children:[{value:"Gossip",id:"gossip",children:[]},{value:"Direct request",id:"direct-request",children:[]},{value:"Resolving dependencies",id:"resolving-dependencies",children:[]}]},{value:"Initial sync",id:"initial-sync",children:[]},{value:"Data availability",id:"data-availability",children:[]},{value:"Layers, the clock, and sync",id:"layers-the-clock-and-sync",children:[]},{value:"Weakly vs. fully synced",id:"weakly-vs-fully-synced",children:[]},{value:"Synchronization status and participation in consensus",id:"synchronization-status-and-participation-in-consensus",children:[]},{value:"Sync and the Tortoise",id:"sync-and-the-tortoise",children:[]}],l={toc:c};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"In order for a node to fully participate in the Spacemesh protocol, including the ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/consensus/overview"},"Consensus protocol"),", it is essential that the node be aware of the current state of the network. This includes knowing the current ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/overview#spacemesh-basics"},"layer and epoch"),", the latest blocks and ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/transactions/overview"},"transactions"),", and the current ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/mining/activations"},"set of eligible miners"),". (Other aspects of the protocol, such as the canonical ledger and the global state, are things the node can work out for itself based on these data.)"),Object(i.b)("p",null,"In addition to receiving ",Object(i.b)("em",{parentName:"p"},"new")," data as it becomes available, this also means that the node must be able to fetch historical data, such as when a new node first comes online, or after a node reconnects to the network after having been offline for some time."),Object(i.b)("p",null,"The Sync subprotocol is the means by which a node achieves this: it sends and receives messages over the Spacemesh ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/p2p/overview"},"P2P network"),", and listens for new blocks and transactions."),Object(i.b)("h2",{id:"getting-data"},"Getting data"),Object(i.b)("p",null,"There are fundamentally only two ways that a node synchronizes data in Spacemesh: gossip and direct request."),Object(i.b)("h3",{id:"gossip"},"Gossip"),Object(i.b)("p",null,"The ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/p2p/overview#gossip"},"gossip protocol")," is the primary way that data are propagated throughout the network. Every time a block receives a new, syntactically valid transaction, it immediately shares it with all of its peers. Every time a miner produces a new candidate block, or receives one from a peer, it immediately shares it with all of its peers. In this way, these data propagate quickly throughout the entire network."),Object(i.b)("h3",{id:"direct-request"},"Direct request"),Object(i.b)("p",null,'Many data structures in Spacemesh, such as blocks and ATXs, rely on (or "point to") other pieces of data. For instance, a block contains a ',Object(i.b)("inlineCode",{parentName:"p"},"view")," that contains the IDs of blocks in previous layers, and it contains the ID of an ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/mining/activations"},"ATX")," that establishes the eligibility of the miner to produce that block in that layer. Similarly, an ATX references a ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/mining/poet"},"PoET proof"),". When a node receives a block or an ATX, it needs to have access to these dependent data structures to perform validation on it."),Object(i.b)("p",null,"When the node receives a new block or ATX, the first thing it does is to attempt to find all of the other pieces of data that the data structure points to. The node first checks its local database, but if it doesn't already have the data (i.e., has never seen this particular piece of data before), then it sends a direct request to its peers for the missing data. If a peer has the data in question, it responds with the data. If none of its peers have the data either, then the data structure in question is deemed invalid."),Object(i.b)("h3",{id:"resolving-dependencies"},"Resolving dependencies"),Object(i.b)("p",null,"Note that these dependencies are recursive: for instance, a block may point to another block that points to an ATX that points to a PoET proof, none of which the node has seen before. The node keeps a separate request queue for each distinct data type, and the dependency tree is explored in breadth-first fashion, and in such a way that the same dependency is never fetched twice. To continue with the example, once the PoET proof is retrieved, it resolves all of the dependencies for the ATX, which is thus validated. This in turn resolves all of the dependencies for the block, which in turn is deemed valid, and so on. The dependencies are unwound in recursive fashion."),Object(i.b)("h2",{id:"initial-sync"},"Initial sync"),Object(i.b)("p",null,"When a node first joins the network, of course it knows nothing about the current state of the network. It completes a ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/p2p/overview#bootstrap-and-peer-discovery"},"bootstrap and peer discovery"),' process to find peers to pair and exchange data with. It next checks whether it\'s in sync with the network: i.e., whether the latest layer that it knows about (the genesis layer, the only layer a new node knows about) is the latest known layer in existence. It will discover newer layers from its peers, thus beginning the sync process. There is no explicit "initial sync"; rather, the sync happens implicitly, via the direct request method described above, as the node receives new data\u2014new blocks and layers\u2014from its peers, and subsequently requests the data that they rely on.'),Object(i.b)("p",null,'Once this initial sync process completes, the node switches into a mode known as "weakly synced" and begins to listen to gossip messages to be notified about new data.'),Object(i.b)("h2",{id:"data-availability"},"Data availability"),Object(i.b)("p",null,"As described above, data structures contain pointers to other data structures. This is to save space in the mesh: it doesn't make sense for every block to contain a copy of all of the other blocks it points to, or to contain the ATX it points to, since many blocks may point to the same one! However, this presents a challenge of data availability: given a piece of data, such as a block, how do we ensure that all of the data that it relies on are available?"),Object(i.b)("p",null,"In short, any data structure is considered invalid in Spacemesh if any of the data it relies on are unavailable (i.e., if none of a node's peers have the missing data). Miners should never mine, or gossip, a block with pointers to invalid or missing data."),Object(i.b)("h2",{id:"layers-the-clock-and-sync"},"Layers, the clock, and sync"),Object(i.b)("p",null,"The syncer polls against the clock and the database to figure out the most recent layer a node should know about, and the most recent layer it actually knows about. Based on this information, it can re-enter syncing mode if the node falls out of sync. If a node is, e.g., temporarily offline, once it comes back online and realizes it's fallen behind, it switches back into sync mode to fetch the missing data."),Object(i.b)("h2",{id:"weakly-vs-fully-synced"},"Weakly vs. fully synced"),Object(i.b)("p",null,"There are two notions of sync in Spacemesh: weakly and fully synced."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Weakly synced")," means that a node knows about the most recent layer in the mesh (which it can calculate using the clock). However, a node that is weakly synced has no way of knowing whether it's seen all of the blocks for this layer."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Fully synced")," means that a node has finished processing all of the blocks for the most recent layer in the mesh."),Object(i.b)("h2",{id:"synchronization-status-and-participation-in-consensus"},"Synchronization status and participation in consensus"),Object(i.b)("p",null,"While a node begins to receive gossip messages as soon as it's connected to peers, some subprotocols such as ",Object(i.b)("inlineCode",{parentName:"p"},"sync")," and ",Object(i.b)("inlineCode",{parentName:"p"},"hare")," discard these messages until the node is weakly synced. This is in order to prevent a DoS attack. Block generation and ATX generation are paused until a node is fully synced, and a node can only participate in the Hare consensus mechanism once it is fully synced."),Object(i.b)("h2",{id:"sync-and-the-tortoise"},"Sync and the Tortoise"),Object(i.b)("p",null,"Sync is what triggers the ",Object(i.b)("a",{parentName:"p",href:"/docs/next/protocol/consensus/overview#tortoise"},"Tortoise protocol")," to validate blocks. This works in two ways."),Object(i.b)("p",null,"For the current layer, Sync waits a specified period of time, called ",Object(i.b)("inlineCode",{parentName:"p"},"ValidationDelta"),", to accumulate blocks. Once this interval has passed, it kicks off the Tortoise to process the votes in these new blocks. In the case where a node is synchronizing historical layers, each layer is processed as soon as all of its blocks are received."),Object(i.b)("p",null,"For blocks that arrive late, i.e., for previous layers, Sync immediately passes the data to the Tortoise."))}d.isMDXComponent=!0},113:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return b}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),d=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=d(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),h=d(n),u=a,b=h["".concat(s,".").concat(u)]||h[u]||p[u]||i;return n?o.a.createElement(b,r(r({ref:t},l),{},{components:n})):o.a.createElement(b,r({ref:t},l))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=u;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var l=2;l<i;l++)s[l]=n[l];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);